#' Get the number of circRNAs identified by each method
#' in each sample
#'
#' A function to count the circRNAs detected by each of the
#' circRNA methods applied
#'
#' @author Enrico Gaffo
#' @param circrnas_gtf the circrnas.gtf generated by CirComPara2
#' @param minreads do not count circRNAs with less than _minreads_
#' @return a data.table with three columns: sample_id, Method, and n_circrnas
#' @import data.table
get_circrnas_per_method <-
  function(circrnas_gtf, minreads = 2) {

    fread(circrnas_gtf)[V6 >= minreads,
                        .(n_circrnas = .N),
                        by = .(sample_id = sub('.*sample_id "([^"]+)";.*',
                                               '\\1', V9),
                               #V1, V4, V5, V7,
                               Method = V2)]
  }


#' Get the total backspliced read number for each method
#'
#' Compute the histogram of circRNA expression detected by each method,
#' per each sample
#'
#' @author Enrico Gaffo
#' @param bks_read_file the file collecting the backspliced reads, i.e.,
#' the bks.counts.collected_reads.csv file
#' @return a data.table with sample_id, circ_method and n_reads columns
#' @import data.table
get_bks_reads_per_method <- function(bks_read_file) {

  fread(bks_read_file)[, .(n_reads = .N), by = .(sample_id, circ_method)]

}

#' Reshape a DCC linear expression matrix into long format
#'
#' Auxiliary function to transform a DCC linear expression matrix into
#' long table format
#'
#' @author Enrico Gaffo
#' @param x DCC linear expression matrix (rows are circRNAs, columns are
#' samples)
#' @return the linear expression in a long table format
#' (three columns: circ_id, sample_id, lin.reads)
#' @import data.table
melt_dcc_linexp_tab <- function(x) {
  ## DCC uses BED coordinates
  data.table::melt(x,
                   id.vars = "circ_id",
                   variable.name = "sample_id",
                   value.name = "lin.reads")
}

#' Get the circRNA parent-gene linear expression
#'
#' Process the circRNA parent-gene linear expression files and merge them into a
#' matrix
#'
#' @author Enrico Gaffo
#' @param lin_reads a text file listing the linear expression table files, or
#' the linear expression table itself. It accepts both CirComPara and DCC
#' tables.
#' @param output_path the directory where to save the results
#' @param output_filename the name of the output file
#' @import data.table
get_linear_bks_reads <- function(lin_reads,
                                 output_path = ".",
                                 output_filename = "ccp_bks_linexp.csv") {

  options(scipen = 999)

  if (lin_reads != "" & file.exists(lin_reads)) {

    ## check if input is a table or a text file listing the linear expression
    ## files
    first_line_dt <- fread(lin_reads, showProgress = F, nrows = 1,
                           header = F)

    ## list files
    if (ncol(first_line_dt) == 1) {
      message("Reading the circRNA parent-gene linear expression file list")
      lin_reads <- readLines(lin_reads)
    }

    ## check whether the files are CirComPara or DCC tables
    first_line_dt <- fread(lin_reads[1], showProgress = F,
                           nrows = 1, header = F)

    if (first_line_dt$V1 == "chr") {
      ## DCC input
      message("CircRNA parent-gene linear expression is from DCC")

      ## samples in various tables need to be merged
      bks_linear_count_tables <-
        lapply(lin_reads, fread, data.table = T,
               showProgress = F, header = T)

      ## bind multiple tables
      bks_linear_counts_tab_m <-
        rbindlist(lapply(bks_linear_count_tables,
                         melt_dcc_linexp_tab),
                  use.names = T)
    }else{
      ## CCP input
      message("CircRNA parent-gene linear expression is from CirComPara")

      bks_linear_counts_tab <-
        rbindlist(lapply(lin_reads, fread, data.table = T,
                         showProgress = F),
                  use.names = T)
      bks_linear_counts_tab[, c("sample_id", "chr") := (tstrsplit(V1, ":"))]

      ## TODO: improve the parsing method to grab the sample name
      bks_linear_counts_tab[, `:=`(sample_id = sub("_bks_linear_counts.tab$",
                                                   "",
                                                   basename(sample_id)),
                                   circ_id = sub('.*"([^"]+)".*', "\\1", V9))]

      bks_linear_counts_tab[, V1 := NULL]
      ## remove strand info from circ_id
      bks_linear_counts_tab[, circ_id := sub(":[-+.]", "", circ_id)]

      ## convert circ_id into BED format
      bks_linear_counts_tab[, c("chr", "start",
                                "end") := tstrsplit(circ_id, ":|-",
                                                    type.convert = T)
      ][, circ_id := paste0(chr,
                            ":", start - 1, "-",
                            end)]

      bks_linear_counts_tab_m <-
        bks_linear_counts_tab[, .(lin.reads = sum(V10)),
                              by = .(sample_id, circ_id)]
    }

    ## save
    bks_linear_counts_tab_filename <- file.path(results.path,
                                                output_filename)
    fwrite(x = bks_linear_counts_tab_m,
           file = bks_linear_counts_tab_filename,
           showProgress = F)

    message(paste("CircRNA parent-gene linear expression saved in file",
                  bks_linear_counts_tab_filename))

  }else{
    warning(paste("File", lin_reads, "is empty or does not exists."))
  }
}


#' Combine circRNA_finder outputs
#'
#' Combine circRNA_finder outputs of multiple samples into a single table
#'
#' @author Enrico Gaffo
#' @param labels a comma-separated string listing the sample names of the files
#' to be merged
#' @param inputs a comma-separated string listing the files to be merged. Input
#' files must be filteredJunctions.bed as resulting from circRNA_finder
#' @param output the file name of the combined table
#' @import data.table
#' @return nothing. Write the combined table into a file in the disk.
merge_cfinder <- function(labels, inputs, output = "") {

  options(scipen = 999)

  if (length(inputs) > 0) {

    labels <- unlist(strsplit(labels, ",", fixed = T))
    inputs <- unlist(strsplit(inputs, ",", fixed = T))
    names(inputs) <- labels

    combined_df <- rbindlist(lapply(inputs, fread, header = F),
                             idcol = "sampleID")

    fwrite(x = combined_df, file = output, sep = "\t", row.names = F,
           col.names = T)

  }else{
    warning("Please give a valid input table file\n")
    stop()
  }
}

#' Combine CIRCexplorer2 outputs
#'
#' Combine CIRCexplorer2 outputs of multiple samples into a single table
#'
#' @author Enrico Gaffo
#' @param labels a comma-separated string listing the sample names of the files
#' to be merged
#' @param inputs a comma-separated string listing the files to be merged. Input
#' files must be circularRNA_known.txt as resulting from CIRCexplorer2
#' @param output the file name of the combined table
#' @import data.table
#' @return nothing. Write the combined table into a file in the disk.
merge_circexplorer <- function(labels, inputs, output = "") {

  options(scipen = 999)

  if (length(inputs) > 0) {

    labels <- unlist(strsplit(labels, ",", fixed = T))
    inputs <- unlist(strsplit(inputs,  ",", fixed = T))
    names(inputs) <- labels
    colnms <- c("chrom", "start", "end", "name", "score", "strand",
                "thickStart", "thickEnd", "itemRgb", "exonCount", "exonSizes",
                "exonOffsets", "readNumber", "circType", "geneName",
                "isoformName", "exonIndex_intronIndex", "flankIntron")

    colcls <- c("factor", "integer", "integer", "factor", "numeric", "factor",
                "integer", "integer", "character", "integer", "character",
                "character", "integer", "factor", "factor", "factor",
                "character", "character")

    combined_df <- rbindlist(lapply(inputs, fread, header = F,
                                    col.names = colnms,
                                    colClasses = colcls),
                             idcol = "sampleID")

    fwrite(x = combined_df, file = output, sep = "\t", row.names = F,
           col.names = T)

  }else{
    warning("Please give a valid input table file\n")

    stop()
  }
}

#' Combine CIRI2 outputs
#'
#' Combine CIRI2 outputs of multiple samples into a single table
#'
#' @author Enrico Gaffo
#' @param labels a comma-separated string listing the sample names of the files
#' to be merged
#' @param inputs a comma-separated string listing the files to be merged. Input
#' files must be _ciri.out as resulting from CIRI2
#' @param output the file name of the combined table
#' @import data.table
#' @return nothing. Write the combined table into a file in the disk.
merge_ciri <- function(labels, inputs, output = "") {

  options(scipen = 999)

  if (length(inputs) > 0) {

    labels <- unlist(strsplit(labels, ",", fixed = T))
    inputs <- unlist(strsplit(inputs,  ",", fixed = T))
    names(inputs) <- labels
    # colnames <- c("circRNA_ID", "chr", "circRNA_start", "circRNA_end",
    #               "#junction_reads", "SM_MS_SMS", "#non_junction_reads",
    #               "junction_reads_ratio", "circRNA_type", "gene_id",
    #               "junction_reads_ID")

    combined_df <- rbindlist(lapply(inputs, fread, header = F),
                             idcol = "sampleID")

    fwrite(x = combined_df, file = output, sep = "\t", row.names = F,
           col.names = T)

  }else{
    warning("Please give a valid input table file\n")

    stop()
  }
}

#' Combine Segemehl outputs
#'
#' Combine Segemehl outputs of multiple samples into a single table
#'
#' @author Enrico Gaffo
#' @param labels a comma-separated string listing the sample names of the files
#' to be merged
#' @param inputs a comma-separated string listing the files to be merged. Input
#' files must be splicesites.bed as resulting from Segemehl
#' @param output the file name of the combined table
#' @param fixstart if TRUE (default), will subtract 1 to the backsplice start
#' position
#' @import data.table
#' @return nothing. Write the combined table into a file in the disk.
merge_segemehl <- function(labels, inputs, output = "", fixstart = T) {

  options(scipen = 999)

  if (length(inputs) > 0) {

    labels <- unlist(strsplit(labels, ",", fixed = T))
    inputs <- unlist(strsplit(inputs, ",", fixed = T))
    names(inputs) <- labels

    colnms <- c("CHR", "POS1", "POS2", "N", "QUAL", "STRAND", "SCORE")
    colcls <- c("factor", "numeric", "numeric", "numeric",
                "numeric", "character", "numeric")

    combined_df <- rbindlist(lapply(inputs, fread, header = F,
                                    col.names = colnms,
                                    colClasses = colcls),
                             idcol = "sampleID")

    if (fixstart) {
      combined_df[, POS1 := POS1 - 1]
    }

    fwrite(x = combined_df[, .(sampleID, CHR, POS1, POS2, QUAL, STRAND, SCORE)],
           file = output, sep = "\t", row.names = F, col.names = T)

  }else{
    warning("Please give a valid input table file\n")
    stop()
  }
}

#' Combine DCC outputs
#'
#' Combine DCC outputs of multiple samples into a single table
#'
#' @author Enrico Gaffo
#' @param labels a comma-separated string listing the sample names of the files
#' to be merged
#' @param inputs a comma-separated string listing the files to be merged. Input
#' files must be CircRNACount as resulting from DCC
#' @param output the file name of the combined table
#' @import data.table
#' @return nothing. Write the combined table into a file in the disk.
merge_dcc	<- function(labels, inputs, output = "") {

  options(scipen = 999)

  if (length(inputs) > 0) {

    labels <- unlist(strsplit(labels, ",", fixed = T))
    inputs <- unlist(strsplit(inputs, ",", fixed = T))
    names(inputs) <- labels

    combined_df <- rbindlist(lapply(inputs, fread, header = T),
                             idcol = "sampleID")

    fwrite(x = combined_df, file = output, sep = "\t", row.names = F,
           col.names = T)

  }else{
    warning("Please give a valid input table file\n")
    stop()
  }
}

#' Add strand to DCC output file
#'
#' Attach strand column to DCC's CircRNACount file. When the CircRNACounts DCC
#' output file does not report the circRNA strand, the strand information can be
#' retrieved from the CircCoordinates file.
#'
#' @author Enrico Gaffo
#' @param counts the CircRNACounts file resulting from DCC
#' @param coordinates the CircCoordinates file resulting from DCC
#' @param output the output file name
#' @return the CircRNACounts table file with a "Strand" column for the strand
#' @import data.table
#' @export
#'
#' @examples
dcc_fix_strand <- function(counts, coordinates, output = "") {

  circrnacounts <- fread(file = counts, header = T)
  coordinates <-
    fread(file = coordinates, header = F,
          col.names = c("Chr", "Start", "End", "info", "score", "Strand"))

  if (! "Strand" %in% colnames(circrnacounts)) {
    circrnacounts <-
      merge(circrnacounts,
            coordinates[, .(Chr, Start, End, Strand)],
            by = c("Chr", "Start", "End"),
            all.x = T)
  }

  fwrite(x = circrnacounts[, .(Chr, Start, End, Strand, Chimeric.out.junction)],
         file = output, row.names = F, sep = "\t", quote = F)

}

#' Combine Findcirc outputs
#'
#' Combine Findcirc outputs of multiple samples into a single table
#'
#' @author Enrico Gaffo
#' @param labels a comma-separated string listing the sample names of the files
#' to be merged
#' @param inputs a comma-separated string listing the files to be merged. Input
#' files must be circ_candidates.bed as resulting from find_circ.py (Findcirc)
#' @param output the file name of the combined table
#' @import data.table
#' @return nothing. Write the combined table into a file in the disk.
merge_findcirc <- function(labels, inputs, output = "") {

  colnames <- c("chrom", "start", "end", "name", "n_reads", "strand",
                "n_uniq", "uniq_bridges", "best_qual_left", "best_qual_rigth",
                "tissues", "tiss_counts", "edits", "anchor_overlap",
                "breakpoints", "signal", "strandmatch", "category")

  options(scipen = 999)

  if (length(inputs) > 0) {

    labels <- unlist(strsplit(labels, ",", fixed = T))
    inputs <- unlist(strsplit(inputs, ",", fixed = T))
    names(inputs) <- labels

    combined_df <- rbindlist(lapply(inputs, fread, header = F,
                                    col.names = colnames),
                             idcol = "sampleID")

    fwrite(x = combined_df, file = output, sep = "\t", row.names = F,
           col.names = T)

  }else{
    warning("Please give a valid input table file\n")
    stop()
  }
}


#' Filter CIRCexplorer2 predictions and reshape into matrix format
#'
#' @param input
#' @param min_reads
#' @param min_methods
#' @param output
#'
#' @return
#' @export
#'
#' @examples
filter_and_cast_circexp <- function(input, min_reads = 2, min_methods = 2,
                                    output = "") {
  #------------------------------------------------------------------------------#
  option_list <- list(
    make_option(c("-i", "--input"), action = "store", type = "character",
                help = "CircRNA expression table file in 'long' format."),
    make_option(c("-r", "--min_reads"), action = "store", type = "integer",
                default = 2,
                help = "The minimum detection read threshold for a circRNA  (in at least one sample)"),
    make_option(c("-m", "--min_methods"), action = "store", type = "integer",
                default = 2,
                help = "Keep circRNAs commonly detected by >= m circRNA detection methods (in at least one sample)"),
    make_option(c("-o", "--output"), action = "store", type = "character",
                default = "./",
                help = "Output file name")
  )

  parser <- OptionParser(usage = paste0("%prog -i bks.counts.union.csv -r 2 -m 2 ",
                                        "-o circexp_count_matrix.csv"),
                         option_list = option_list)
  arguments <- parse_args(parser, positional_arguments = F)

  input_file <- arguments$input
  min_reads <- arguments$min_reads
  min_methods <- arguments$min_methods
  output_file <- arguments$output

  tab <- fread(input_file,
               header = T,
               showProgress = F)[read.count >= min_reads &
                                   n_methods >= min_methods]

  if ("strand" %in% colnames(tab)) {
    tab[, circ_id := paste0(chr, ":", start, "-", end, ":", strand)]
  }else{
    tab[, circ_id := paste0(chr, ":", start, "-", end)]
  }

  ## TODO: print out some statistics of the filtering

  fwrite(x = dcast(tab, circ_id ~ sample_id, value.var = "read.count", fill = 0),
         file = output_file,
         sep = "\t",
         row.names = F,
         col.names = T)

}

filter_findcirc_res <- function() {
  #------------------------------------------------------------------------------#
  #!/usr/bin/env Rscript

  suppressPackageStartupMessages(library(optparse))
  suppressPackageStartupMessages(library(data.table))

  option_list <- list(
    make_option(c("-i", "--input"), action = "store", type = "character",
                help = "Findcirc result table file"),
    make_option(c("-q", "--minqual"), action = "store", type = "integer",
                default = 40,
                help = "Minimum quality of backsplice end mapping"),
    make_option(c("-f", "--filter_tags"), action = "store", type = "character",
                default = 'CIRCULAR',
                help = "Comma separated list of flags that have to be present in rows of the Find_circ BED file"),
    make_option(c("-o", "--output"), action = "store", type = "character",
                default = "filteredFindcirc.bed", help = "The output file")
  )

  parser <- OptionParser(usage = "%prog -i circ_candidates.bed -q 40 -f CIRCULAR -o filteredFindcirc.bed",
                         option_list = option_list,
                         description = "Filter Findcirc results by quality")
  arguments <- parse_args(parser, positional_arguments = F)
  input <- arguments$input
  output <- arguments$output
  minqual <- arguments$minqual
  flags <- unlist(strsplit(arguments$filter_tags, ','))
  if (length(flags) < 1) {
    flags <- '.'
  }

  circ_candidates.bed <-
    fread(cmd = paste0(c(paste0("grep -v '^#' ", input),
                         flags),
                       collapse = " | grep -w "),
          showProgress = F)

  if (nrow(circ_candidates.bed) > 0) {
    circ_candidates.bed <- circ_candidates.bed[V9 >= minqual & V10 >= minqual]
  }

  write.table(x = circ_candidates.bed,
              file = output, row.names = F, quote = F, sep = "\t", col.names = F)

}


filter_segemehl.R	 <- function() {

  #------------------------------------------------------------------------------#
  #!/usr/bin/env Rscript

  suppressPackageStartupMessages(library(optparse))
  suppressPackageStartupMessages(library(data.table))

  options(scipen = 999)

  option_list <- list(
    make_option(c("-i", "--input"), action = "store", type = "character",
                default = "sample.sngl.bed",
                help = "Segemehl result table file"),
    make_option(c("-q", "--minqual"), action = "store", type = "character",
                default = "median_10",
                help = paste("Filter function and minimum mapping quality of backsplice-reads. ",
                             "Function supported: ",
                             "- median: for each backsplice compute the read mapping median quality and discard backsplices with median quality <= N",
                             "- mean: as for median, but compute the mean instead",
                             "- any: first, discard any alignment with mapping quality <= N. Then, report the median as backsplice quality",
                             sep = "\n")),
    make_option(c("-o", "--count_output"), action = "store", type = "character",
                default = "splicesites.bed",
                help = "The filtered circrnas in BED format. The 7th column is just a copy of the score field and reports the read count."),
    make_option(c("-r", "--reads_output"), action = "store", type = "character",
                default = "sample.circular.reads.bed.gz",
                help = "The output file"),
    make_option(c("-m", "--keep_mates"), action = "store_true", #type = "logical",
                default = F,
                help = "Whether to include /1 or /2 in read names to distinguish readmates"),
    make_option(c("-t", "--trns_file"), action = "store", type = "character",
                default = "unmapped_1.fastq.trns.txt",
                help = "The *trns.txt file output by Segemehl"),
    make_option(c("-l", "--legacy_output"), action = "store", type = "character",
                default = "old_splicesites.bed",
                help = "The filename for Segemehl splicesites.bed in Segemehl < v0.3 format")
  )

  parser <- OptionParser(usage = paste0("%prog -i sample.sngl.bed -q median_10 -o splicesites.bed",
                                        " -r sample.circular.reads.bed.gz -t unmapped_1.fastq.trns.txt"),
                         option_list = option_list,
                         description = "Filter segemehl results by alignments' quality and compute backsplices' read count")
  arguments <- parse_args(parser, positional_arguments = F)
  input <- arguments$input
  count_output <- arguments$count_output
  reads_output <- arguments$reads_output
  min.qual <- arguments$minqual
  trns.file <- arguments$trns_file
  old_output <- arguments$legacy_output

  split.qual.par <- strsplit(min.qual, "_", fixed = T)[[1]]
  if (length(split.qual.par) > 1) {
    qual.func <- split.qual.par[1]
    if (!qual.func %in% c("median", "mean", "any")) {
      message("Error in evaluating quality function in '", min.qual, "': setting default 'median'")
      qual.func <- "median"
    }
    minqual <- suppressWarnings(as.numeric(split.qual.par[2]))
    if (is.na(minqual)) {
      message("Error in evaluating quality value in '", min.qual, "': setting default '10'")
      minqual <- 10
    }
  }else{
    message("Error in evaluating quality function '", min.qual, "': setting default 'median_10'")
    qual.func <- "median"
    minqual <- 10
  }

  # Start and end position indicate the genomic range of the predicted intron.
  # The name has the format (read-group;type;read-name;mate-status), the bed
  # score is the alignment score of the respective alignment. The type is either
  # 'R' (in case of a regular, collinear split), 'C' (circular split) or 'B' (backsplice)

  sege_circ <- fread(cmd = paste0('grep ";B\\|C;" ', input),
                     header = F, skip = 1)

  # Add backspliced reads from the transplice file (backsplices > 20000 bp length)
  trns.fields <- c("chr","pos","strand","start.in.read","align.length","algin.edist","score")

  trns <- fread(trns.file, header = F, sep = "\t")
  trns[, paste0(trns.fields,"_L") := tstrsplit(V1, ",", type.convert = T)]
  trns[, paste0(trns.fields,"_R") := tstrsplit(V2, ",", type.convert = T)]

  trns.samechr.reads <-
    trns[chr_L == chr_R &
           strand_L == strand_R &
           align.length_L >= 20 & align.length_R >= 20]

  trns.bks.reads <-
    rbindlist(list(trns.samechr.reads[strand_L == "+" & pos_L > pos_R, ## select backsplices on forward strand
                                      .(chr = chr_L,
                                        start = as.integer(pos_R) - 1, ## scale by 1 to comply with BED format
                                        end = as.integer(pos_L) + as.integer(align.length_L) - 1,
                                        read.name = V3,
                                        score = ifelse(score_L > score_R,
                                                       as.integer(score_L),
                                                       as.integer(score_R)),
                                        strand = strand_L)],
                   trns.samechr.reads[strand_L == "-" & pos_L < pos_R,  ## select backsplices on reverse strand
                                      .(chr = chr_L,
                                        start = as.integer(pos_L) - 1, ## scale by 1 to comply with BED format
                                        end = as.integer(pos_R) + align.length_R - 1,
                                        read.name = V3,
                                        score = ifelse(score_L > score_R,
                                                       as.integer(score_L),
                                                       as.integer(score_R)),
                                        strand = strand_L)]),
              use.names = T)[, .(V1 = chr, V2 = start, V3 = end,
                                 V5 = score, V6 = strand, read.name)]

  splicesites.bed <- data.table()
  reads_output.dt <- data.table()

  if (qual.func == "any") {
    sege_circ <- sege_circ[V5 >= minqual]
    trns.bks.reads <- trns.bks.reads[V5 >= minqual]
  }

  if (nrow(sege_circ) > 0) {

    if (arguments$keep_mates) {
      sege_circ[, c("read.group", "type", "read.name",
                    "mate.status"):=(tstrsplit(V4, ";"))][, read.name :=
                                                            paste0(read.name, "/",
                                                                   mate.status)][, `:=`(V4 = NULL,
                                                                                        read.group = NULL,
                                                                                        type = NULL,
                                                                                        mate.status = NULL)]
    }else{
      sege_circ[, c("read.group", "type", "read.name",
                    "mate.status"):=(tstrsplit(V4, ";"))][, `:=`(V4 = NULL,
                                                                 read.group = NULL,
                                                                 type = NULL,
                                                                 mate.status = NULL)]
    }

    sege_circ <- rbindlist(list(sege_circ,
                                trns.bks.reads),
                           use.names = T)

    ## remove duplicated lines/alignments
    sege_circ <- sege_circ[, .(multi.mapping = .N,
                               map.qual = max(V5)),
                           by = .(chr = V1, left = V2,
                                  right = V3, read.name,
                                  strand = V6)]

    if (qual.func == "any" || qual.func == "median") {
      splicesites.bed <-
        sege_circ[, .(n = .N,
                      map.qual = median(map.qual)),
                  by = .(chr, left, right,
                         strand)][, .(chr, left, right, n, map.qual, strand,
                                      score = n)][order(chr, left,
                                                        right)]
    }

    if (qual.func == "mean") {
      splicesites.bed <-
        sege_circ[, .(n = .N,
                      map.qual = mean(map.qual)),
                  by = .(chr, left, right,
                         strand)][, .(chr, left, right, n, map.qual, strand,
                                      score = n)][order(chr, left,
                                                        right)]
    }

    if (qual.func == "median" || qual.func == "mean") {
      ## filter by quality
      splicesites.bed <- splicesites.bed[map.qual >= minqual]
    }

    ## report selected backsplices' read names
    # reads_output.dt <- sege_circ[, .(chr, left, right, read.name, map.qual, strand)]
    reads_output.dt <- sege_circ[splicesites.bed[, .(chr, left, right, strand)],
                                 on = c("chr", "left", "right",
                                        "strand")][, .(chr, left, right, read.name,
                                                       map.qual, strand)]
  }

  ## write backsplice counts
  write.table(x = splicesites.bed,
              file = count_output,
              row.names = F, quote = F, sep = "\t", col.names = T)

  ## write gzipped file for circular reads
  reads_output.gz <- gzfile(reads_output, "w")
  write.table(x = reads_output.dt,
              file = reads_output.gz,
              row.names = F, quote = F, sep = "\t", col.names = F)
  close(reads_output.gz)

  ## write old segemehl format
  write.table(x = splicesites.bed[, .(V4 = paste("splits", sum(n), sum(n), sum(n), "C", "P", sep=":")),
                                  by = .(chr, left, right)][order(chr, left, right),
                                                            .(chr, left = left+1, right, V4, 0, "+")],
              file = old_output,
              row.names = F, quote = F, sep = "\t", col.names = F)


}

#' Switch between forward and reverse strands
#'
#' A function to invert the strand sign
#'
#' @param s the strand to be inverted. Must be "+" or "-"
#'
#' @return the opposite of the input strand
#' @export
#'
#' @examples
switch_strand <- function(s) {

  ifelse(s == "+", "-", "+")
}

get_ce2_bwa_bks_reads <- function() {
  #------------------------------------------------------------------------------#

  #!/usr/bin/env Rscript

  suppressPackageStartupMessages(library(optparse))
  suppressPackageStartupMessages(library(data.table))
  suppressPackageStartupMessages(library(R.utils))

  option_list <- list(
    make_option(c("-r", "--chimreads"), action="store", type="character",
                help="sample_bwa.sam.gz BED transformed by get_ce2_bwa_circ_reads.py"),
    make_option(c("-c", "--circrnas"), action="store", type="character",
                help="circularRNA_known.txt as output by CIRCexplorer2 annotate, or back_spliced_junction.bed as output by CIRCexplorer2 parse"),
    make_option(c("-o", "--output"), action="store", type="character",
                help="The circRNA read IDs for each circRNA in compressed BED (circular.reads.bed.gz)"),
    make_option(c("-g", "--range"), action="store", type="integer", default = 10,
                help="Number of basepairs tolerated in realigning circRNAs from CIRCexplorer2 annotate"),
    make_option(c("-d", "--discriminate_mates"), action="store_true", default = FALSE,
                help="By default, reads will be collapsed by read ID and position. Enable this option to discriminate paired-end read mates by appending \1 or \2 to read IDs."),
    make_option(c("-s", "--stranded"), action="store_true", default = FALSE,
                help="Do not consider strand of alignments. The reported strand will be copied from CIRCexplorer2 annotate results")
  )

  parser <-
    OptionParser(usage="%prog -r sample_bwa.sam.gz -c circularRNA_known.txt -o circular.reads.bed.gz",
                 option_list=option_list)
  arguments <- parse_args(parser, positional_arguments=F)

  orig.file <- arguments$circrnas

  if (file.info(orig.file)$size > 0) {

    orig.est <- fread(file = orig.file, header = F)
    annotation <- "bed"
    if (ncol(orig.est) > 6) {
      annotation <- "annotated"
    }

    orig.est <- orig.est[, .(V1, V2, V3, V5, V6)]
    orig.est$V1 <- as.character(orig.est$V1)

    bks.reads.file <- arguments$chimreads
    bks.reads <- fread(bks.reads.file, showProgress = F)
    bks.reads$V1 <- as.character(bks.reads$V1)

    merge.fields <- c("V1", "V2", "V3")
    if (arguments$stranded) {
      merge.fields <- c(merge.fields, "V6")
    }else{
      bks.reads <- unique(bks.reads[, .(V1, V2, V3, V4, V5)])
    }

    if (arguments$discriminate_mates) {
      bks.reads[, V4 := paste0(V4, "/", V5)]
    }else{
      bks.reads <- bks.reads[, .(V5 = paste0(V5, collapse = ",")),
                             by = c(merge.fields, "V4")]
    }

    if (annotation == "annotated") {

      unfixed.bks.reads <-
        merge(bks.reads,
              orig.est[V5 == 0],
              by = merge.fields)[, .(V1, V2, V3, V4, V5 = V5.y, V6)]

      chimout.slices <- list(unf = unfixed.bks.reads)

      ## circrnas missed
      # nrow(orig.est[V5 == 0]) - nrow(unfixed.bks.reads[, .(ccp = .N), by = .(V1, V2, V3, V6)])
      ## check if the missed circrnas have just a diferent strand
      unmatched <-
        merge(orig.est[V5 == 0],
              unfixed.bks.reads[, .(ccp = .N), by = .(V1, V2, V3, V6)],
              by = c("V1", "V2", "V3", "V6"),
              all = T)[is.na(ccp)]

      if (nrow(unmatched) > 0) {
        unmatched$V6 <- sapply(unmatched$V6, switch_strand)
        strand.switched <-
          merge(unmatched,
                bks.reads,
                by = c("V1", "V2", "V3", "V6"),
                all.y = F)[, .(V1, V2, V3,
                               V4, V5 = V5.y,
                               V6)]

        ## missed circrnas fixed by strand switch
        # nrow(strand.switched[, .(ccp = .N), by = .(V1, V2, V3, V6)])
        if (nrow(strand.switched[, .(ccp = .N), by = .(V1, V2, V3, V6)]) > 0) {
          chimout.slices$unf.str.swi <-
            strand.switched[, .(V1, V2, V3, V4, V5,
                                V6 = sapply(V6, switch_strand))]
        }
        ## check if now the matched circrnas correspond to the
        ## circexplorer-unmodified circrnas
        # nrow(orig.est[V5 == 0]) == nrow(rbindlist(list(unfixed.bks.reads,
        #                                                strand.switched),
        #                                           use.names = T)[, .(ccp = .N), by = .(V1, V2, V3, V6)])
      }
      ## now, check the circexplorer-MODIFIED circrnas

      ## number of ce2-modified circrnas
      if (nrow(orig.est[V5 != 0]) > 0) {

        ## prepare tolerance intervals for coordinate fix
        ext.range <- c(-arguments$range:arguments$range)
        ext.range <- ext.range[ext.range != 0]
        unfix.orig.est <-
          orig.est[V5 != 0, .(start = V2 + ext.range,
                              end = V3 + ext.range),
                   by = .(V1, fixed.V2 = V2, fixed.V3= V3, V6)]

        ## search the reads with the extended coordinates
        ## fixed.bks.reads will be the extended coordinates-found reads
        y.merge.fields <- c("V1", "start", "end")
        if (arguments$stranded) {
          y.merge.fields <- c(y.merge.fields, "V6")
        }
        fixed.bks.reads <-
          merge(bks.reads,
                unfix.orig.est,
                by.x = merge.fields, #c("V1", "V2", "V3", "V6"),
                by.y = y.merge.fields)[, .(V1, V2 = fixed.V2,
                                           V3 = fixed.V3, V4,
                                           V5, V6)]

        ## check if some circrna is still missed also after coordinate extension search
        fixed.match <-
          merge(orig.est[V5 != 0],
                fixed.bks.reads[, .N, by = .(V1, V2, V3, V6)],
                by = merge.fields, #c("V1", "V2", "V3", "V6"),
                all = T)

        if (nrow(fixed.match[!is.na(N)]) > 0) {
          ## store fixed coordinates for reads
          chimout.slices$fix.coo <-
            merge(bks.reads,
                  unfix.orig.est,
                  by.x = merge.fields,
                  by.y = y.merge.fields,
                  all = F)[, .(V1, V2 = fixed.V2,
                               V3 = fixed.V3, V4,
                               V5, V6)]
        }

        still.missed <- fixed.match[is.na(N)]
        if (any("V6.x" == colnames(still.missed))) {
          still.missed[, V6 := V6.x]
          still.missed[, V6.x := NULL]
          still.missed[, V6.y := NULL]
        }
        if (nrow(still.missed) > 0) {
          ## check if the still missed have a different strand in reads
          still.missed$V6 <- sapply(still.missed$V6, switch_strand)

          ## expand interval of still missed
          extended.still.missed <-
            still.missed[, .(start = V2 + ext.range,
                             end = V3 + ext.range),
                         by = .(V1, fixed.V2 = V2, fixed.V3= V3, V6)]

          ext.merge.fields <- c("V1", "start", "end")
          if (any("V6" == merge.fields)) {
            ext.merge.fields <- c(ext.merge.fields, "V6")
          }
          still.missed.strand.switched <-
            merge(bks.reads,
                  extended.still.missed,
                  by.x = merge.fields,
                  by.y = ext.merge.fields)[, .(V1, V2 = fixed.V2,
                                               V3 = fixed.V3, V4,
                                               V5, V6)]

          ## missed circrnas fixed by strand switch
          if (nrow(still.missed.strand.switched[, .(ccp = .N), by = .(V1, V2, V3, V6)]) > 0) {
            ## store fixed coordinates and strand for reads
            chimout.slices$fix.coo.str <-
              merge(bks.reads,
                    extended.still.missed,
                    by.x = merge.fields,
                    by.y = ext.merge.fields)[, .(V1, V2 = fixed.V2,
                                                 V3 = fixed.V3,
                                                 V4, V5,
                                                 V6 = sapply(V6, switch_strand))]
          }
        }
      }

      ## bind all reads (all.seg.bks.reads)
      annotated.chimout.junc <-
        rbindlist(chimout.slices,
                  use.names = T,
                  idcol = "Set")

      ## check the number of identified circrnas
      # nrow(orig.est) - nrow(annotated.bks.reads[, .(ccp = .N), by = .(V1, V2, V3, V6)])

    }else{

      annotated.chimout.junc <-
        merge(bks.reads[, .(V1, V2, V3, V4, V6)],
              orig.est[, .(V1, V2, V3, V5, V6)],
              by = c("V1", "V2", "V3", "V6"), all.x = F, all.y = T)
    }

    splitted.filename <- strsplit(arguments$output, ".", fixed = T)[[1]]
    if (tail(splitted.filename, 1) == "gz") {
      tmp.outfile <- sub(".gz$", "", arguments$output)
    }

    annotated.chimout.junc <- annotated.chimout.junc[, .(V1, V2, V3, V4, V5, V6)]

    fwrite(x = annotated.chimout.junc,
           file = tmp.outfile,
           sep = "\t",
           col.names = F,
           row.names = F)

    if (tail(splitted.filename, 1) == "gz") {
      gzip(tmp.outfile, destname = arguments$output)
    }
  }else{
    warning(paste("No circRNAs in input file", orig.file))
    file.create(arguments$output)
  }


}


get_ce2_segemehl_bks_reads <- function() {
  #------------------------------------------------------------------------------#
  #!/usr/bin/env Rscript

  suppressPackageStartupMessages(library(optparse))
  suppressPackageStartupMessages(library(data.table))
  suppressPackageStartupMessages(library(R.utils))

  option_list <- list(
    make_option(c("-r", "--chimreads"), action="store", type="character",
                help="sample.sngl.bed plus sample.trns.txt merged bks read as from filter_testrealign.R"),
    make_option(c("-c", "--circrnas"), action="store", type="character",
                help="circularRNA_known.txt as output by CIRCexplorer2 annotate, or back_spliced_junction.bed as output by CIRCexplorer2 parse"),
    make_option(c("-o", "--output"), action="store", type="character",
                help="The circRNA read IDs for each circRNA in compressed BED (circular.reads.bed.gz)"),
    make_option(c("-g", "--range"), action="store", type="integer", default = 10,
                help="Number of basepairs tolerated in realigning circRNAs from CIRCexplorer2 annotate"),
    make_option(c("-d", "--discriminate_mates"), action="store_true", default = FALSE,
                help="By default, reads will be collapsed by read ID and position. Enable this option to discriminate paired-end read mates by appending \1 or \2 to read IDs.")
  )

  parser <-
    OptionParser(usage="%prog -r sample.sngl.bed -c circularRNA_known.txt -o circular.reads.bed.gz",
                 option_list=option_list)
  arguments <- parse_args(parser, positional_arguments=F)

  orig.file <- arguments$circrnas

  if (file.info(orig.file)$size > 0) {

    orig.est <- fread(file = orig.file, header = F)
    annotation <- "bed"
    if (ncol(orig.est) > 6) {
      annotation <- "annotated"
    }

    orig.est <- orig.est[, .(V1, V2, V3, V5, V6)]
    orig.est$V1 <- as.character(orig.est$V1)

    bks.reads.file <- arguments$chimreads
    # bks.reads <-
    #     fread(bks.reads.file, showProgress = F,
    #           skip = 1)[grepl(";C|B;", V4)]
    # bks.reads$V1 <- as.character(bks.reads$V1)
    # bks.reads <-
    #     bks.reads[, c("read.group", "type", "read.name",
    #                       "mate.status") :=
    #                       tstrsplit(V4, ";",
    #                                 type.convert = T)]
    bks.reads <- fread(bks.reads.file, showProgress = F, header = F,
                       col.names = c("V1", "V2", "V3", "read.name", "V5", "V6"))

    # if (arguments$discriminate_mates) {
    #     bks.reads[, read.name :=
    #                   paste0(read.name, "/",
    #                          mate.status)]
    # }

    # bks.reads <- unique(bks.reads[, `:=`(V4 = NULL,
    #                                      read.group = NULL,
    #                                      mate.status = NULL)])

    if (annotation == "annotated") {

      unfixed.bks.reads <-
        merge(bks.reads,
              orig.est[V5 == 0],
              by = c("V1", "V2", "V3",
                     "V6"))[, .(V1, V2, V3,
                                V4 = read.name, V5 = V5.y,
                                V6)]

      chimout.slices <- list(unf = unfixed.bks.reads)

      ## circrnas missed
      # nrow(orig.est[V5 == 0]) - nrow(unfixed.bks.reads[, .(ccp = .N), by = .(V1, V2, V3, V6)])

      ## check if the missed circrnas have just a diferent strand
      unmatched <-
        merge(orig.est[V5 == 0],
              unfixed.bks.reads[, .(ccp = .N), by = .(V1, V2, V3, V6)],
              by = c("V1", "V2", "V3", "V6"),
              all = T)[is.na(ccp)]

      if (nrow(unmatched) > 0) {

        unmatched$V6 <- sapply(unmatched$V6, switch_strand)
        strand.switched <-
          merge(unmatched,
                bks.reads,
                by = c("V1", "V2", "V3", "V6"),
                all.y = F)[, .(V1, V2, V3,
                               V4 = read.name, V5 = V5.y,
                               V6)]

        ## missed circrnas fixed by strand switch
        # nrow(strand.switched[, .(ccp = .N), by = .(V1, V2, V3, V6)])
        if (nrow(strand.switched[, .(ccp = .N), by = .(V1, V2, V3, V6)]) > 0) {
          chimout.slices$unf.str.swi <-
            strand.switched[, .(V1, V2, V3, V4, V5,
                                V6 = sapply(V6, switch_strand))]
        }
        ## check if now the matched circrnas correspond to the
        ## circexplorer-unmodified circrnas
        # nrow(orig.est[V5 == 0]) == nrow(rbindlist(list(unfixed.bks.reads,
        #                                                strand.switched),
        #                                           use.names = T)[, .(ccp = .N), by = .(V1, V2, V3, V6)])
      }
      ## now, check the circexplorer-MODIFIED circrnas

      ## number of ce2-modified circrnas
      # nrow(orig.est[V5 != 0])

      if (nrow(orig.est[V5 != 0]) > 0) {
        ## prepare tolerance intervals for coordinate fix
        ext.range <- c(-arguments$range:arguments$range)
        ext.range <- ext.range[ext.range != 0]
        unfix.orig.est <-
          orig.est[V5 != 0, .(start = V2 + ext.range,
                              end = V3 + ext.range),
                   by = .(V1, fixed.V2 = V2, fixed.V3= V3, V6)]

        ## search the reads with the extended coordinates
        ## fixed.bks.reads will be the extended coordinates-found reads
        fixed.bks.reads <-
          merge(bks.reads,
                unfix.orig.est,
                by.x = c("V1", "V2", "V3", "V6"),
                by.y = c("V1", "start", "end",
                         "V6"))[, .(V1, V2 = fixed.V2,
                                    V3 = fixed.V3, V4 = read.name,
                                    V5, V6)]

        ## check if some circrna is still missed also after coordinate extension search
        fixed.match <-
          merge(orig.est[V5 != 0],
                fixed.bks.reads[, .N, by = .(V1, V2, V3, V6)],
                by = c("V1", "V2", "V3", "V6"),
                all = T)#[orig - N != 0]

        if (nrow(fixed.match[!is.na(N)]) > 0) {
          ## store fixed coordinates for reads
          chimout.slices$fix.coo <-
            merge(bks.reads,
                  unfix.orig.est,
                  by.x = c("V1", "V2", "V3", "V6"),
                  by.y = c("V1", "start", "end",
                           "V6"),
                  all = F)[, .(V1, V2 = fixed.V2,
                               V3 = fixed.V3, V4 = read.name,
                               V5, V6)]
        }

        still.missed <- fixed.match[is.na(N)]

        if (nrow(still.missed) > 0) {
          ## check if the still missed have a different strand in reads
          still.missed$V6 <- sapply(still.missed$V6, switch_strand)

          ## expand interval of still missed
          extended.still.missed <-
            still.missed[, .(start = V2 + ext.range,
                             end = V3 + ext.range),
                         by = .(V1, fixed.V2 = V2, fixed.V3= V3, V6)]

          still.missed.strand.switched <-
            merge(bks.reads,
                  extended.still.missed,
                  by.x = c("V1", "V2", "V3", "V6"),
                  by.y = c("V1", "start", "end",
                           "V6"))[, .(V1, V2 = fixed.V2,
                                      V3 = fixed.V3, V4 = read.name,
                                      V5, V6)]

          ## missed circrnas fixed by strand switch
          if (nrow(still.missed.strand.switched[, .(ccp = .N), by = .(V1, V2, V3, V6)]) > 0) {
            ## store fixed coordinates and strand for reads
            chimout.slices$fix.coo.str <-
              merge(bks.reads,
                    extended.still.missed,
                    by.x = c("V1", "V2", "V3", "V6"),
                    by.y = c("V1", "start", "end",
                             "V6"))[, .(V1, V2 = fixed.V2,
                                        V3 = fixed.V3,
                                        V4 = read.name, V5,
                                        V6 = sapply(V6, switch_strand))]
          }
        }
      }


      ## check the number of identified circrnas
      # nrow(annotated.bks.reads[, .(ccp = .N), by = .(V1, V2, V3, V6)]) == nrow(orig.est)
      annotated.chimout.junc <-
        rbindlist(chimout.slices,
                  use.names = T,
                  idcol = "Set")
    }else{

      annotated.chimout.junc <- bks.reads[, .(V1, V2, V3, V4, V6)]
    }

    splitted.filename <- strsplit(arguments$output, ".", fixed = T)[[1]]
    if (tail(splitted.filename, 1) == "gz") {
      tmp.outfile <- sub(".gz$", "", arguments$output)
    }

    annotated.chimout.junc <- annotated.chimout.junc[, .(V1, V2, V3, V4, V5, V6)]

    fwrite(x = annotated.chimout.junc,
           file = tmp.outfile,
           sep = "\t",
           col.names = F,
           row.names = F)

    if (tail(splitted.filename, 1) == "gz") {
      gzip(tmp.outfile, destname = arguments$output)
    }

  }else{
    warning(paste("No circRNAs in input file", orig.file))
    file.create(arguments$output)
  }

}

get_ce2_star_bks_reads <- function() {

  #------------------------------------------------------------------------------#
  #!/usr/bin/env Rscript

  suppressPackageStartupMessages(library(optparse))
  suppressPackageStartupMessages(library(data.table))
  suppressPackageStartupMessages(library(R.utils))

  option_list <- list(
    make_option(c("-r", "--chimreads"), action="store", type="character",
                help="Chimeric.out.junction BED transformed by chimout_junc_to_bed.py"),
    make_option(c("-c", "--circrnas"), action="store", type="character",
                help="circularRNA_known.txt as output by CIRCexplorer2 annotate, or back_spliced_junction.bed as output by CIRCexplorer2 parse"),
    make_option(c("-o", "--output"), action="store", type="character",
                help="The circRNA read IDs for each circRNA in compressed BED (circular.reads.bed.gz)"),
    make_option(c("-g", "--range"), action="store", type="integer", default = 10,
                help="Number of basepairs tolerated in realigning circRNAs from CIRCexplorer2 annotate")
  )

  parser <-
    OptionParser(usage="%prog -r Chimeric.out.junction.bed -c circularRNA_known.txt -g 10 -o circular.reads.bed.gz",
                 option_list=option_list)
  arguments <- parse_args(parser, positional_arguments=F)

  orig.file <- arguments$circrnas

  if (file.info(orig.file)$size > 0) {

    orig.est <- fread(file = orig.file, header = F)
    annotation <- "bed"
    if (ncol(orig.est) > 6) {
      annotation <- "annotated"
    }

    orig.est <- orig.est[, .(V1, V2, V3, V5, V6)]
    orig.est$V1 <- as.character(orig.est$V1)

    chimout.junc.file <- arguments$chimreads
    chimout.junc.bed <- fread(file = chimout.junc.file, header = F)
    chimout.junc.bed$V1 <- as.character(chimout.junc.bed$V1)

    if (annotation == "annotated") {
      ext.range <- c(-arguments$range:arguments$range)
      ext.range <- ext.range[ext.range != 0]
      unfix.orig.est <-
        orig.est[V5 != 0, .(start = V2 + ext.range,
                            end = V3 + ext.range),
                 by = .(V1, fixed.V2 = V2, fixed.V3= V3, V6)]

      fixed.chimout.junc <-
        merge(chimout.junc.bed,
              unfix.orig.est,
              by.x = c("V1", "V2", "V3"),
              by.y = c("V1", "start", "end"))[, .(V1, V2 = fixed.V2,
                                                  V3 = fixed.V3, V4, V5, V6 = V6.y)]


      unfixed.chimout.junc <-
        merge(chimout.junc.bed,
              orig.est[V5 == 0],
              by = c("V1", "V2", "V3"))[, .(V1, V2, V3, V4, V5 = V5.y, V6 = V6.y)]

      annotated.chimout.junc <-
        rbindlist(list(fixed.chimout.junc,
                       unfixed.chimout.junc),
                  use.names = T)
    }else{
      annotated.chimout.junc <-
        merge(chimout.junc.bed[, .(V1, V2, V3, V4)],
              orig.est[, .(V1, V2, V3, V5, V6)],
              by = c("V1", "V2", "V3"), all.x = F, all.y = T)
    }

    splitted.filename <- strsplit(arguments$output, ".", fixed = T)[[1]]
    if (tail(splitted.filename, 1) == "gz") {
      tmp.outfile <- sub(".gz$", "", arguments$output)
    }

    annotated.chimout.junc <- annotated.chimout.junc[, .(V1, V2, V3, V4, V5, V6)]

    fwrite(x = annotated.chimout.junc,
           file = tmp.outfile,
           sep = "\t",
           col.names = F,
           row.names = F)

    if (tail(splitted.filename, 1) == "gz") {
      gzip(tmp.outfile, destname = arguments$output)
    }
  }else{
    warning(paste("No circRNAs in input file", orig.file))
    file.create(arguments$output)
  }

}

get_ce2_th_bks_reads <- function() {

  #------------------------------------------------------------------------------#
  #!/usr/bin/env Rscript

  suppressPackageStartupMessages(library(optparse))
  suppressPackageStartupMessages(library(data.table))
  suppressPackageStartupMessages(library(R.utils))

  option_list <- list(
    make_option(c("-r", "--chimreads"), action="store", type="character",
                help="back_spliced_junction.bed BED file output by CIRCexplorer parse TopHat >= v2.3.5"),
    make_option(c("-c", "--circrnas"), action="store", type="character",
                help="circularRNA_known.txt as output by CIRCexplorer2 annotate, or back_spliced_junction.bed as output by CIRCexplorer2 parse"),
    make_option(c("-o", "--output"), action="store", type="character",
                help="The circRNA read IDs for each circRNA in compressed BED (circular.reads.bed.gz)"),
    make_option(c("-g", "--range"), action="store", type="integer", default = 10,
                help="Number of basepairs tolerated in realigning circRNAs from CIRCexplorer2 annotate")
  )

  parser <-
    OptionParser(usage="%prog -r back_spliced_junction.bed -c circularRNA_known.txt -o circular.reads.bed.gz",
                 option_list=option_list)
  arguments <- parse_args(parser, positional_arguments=F)

  orig.file <- arguments$circrnas

  if (file.info(orig.file)$size > 0) {

    orig.est <- fread(file = orig.file, header = F)
    annotation <- "bed"
    if (ncol(orig.est) > 6) {
      annotation <- "annotated"
    }

    orig.est <- orig.est[, .(V1, V2, V3, V5, V6)]
    orig.est$V1 <- as.character(orig.est$V1)

    bks.reads.file <- arguments$chimreads
    bks.reads <- fread(bks.reads.file, header = F)[, V4 := V7][, V7 := NULL][]
    bks.reads$V1 <- as.character(bks.reads$V1)
    bks.reads <-
      bks.reads[, strsplit(V4, ",", fixed = TRUE),
                by = .(chr = V1, V2, V3, V5,
                       V6)][, c("V4",
                                "th.cig") := tstrsplit(V1, ";",
                                                       fixed = T)][, `:=`(V1 = chr,
                                                                          th.cig = NULL)][, chr := NULL][]

    if (annotation == "annotated") {

      unfixed.bks.reads <-
        merge(bks.reads,
              orig.est[V5 == 0],
              by = c("V1", "V2", "V3",
                     "V6"))[, .(V1, V2, V3, V4, V5 = V5.y, V6)]

      chimout.slices <- list(unf = unfixed.bks.reads)

      ## circrnas missed
      # nrow(orig.est[V5 == 0]) - nrow(unfixed.bks.reads[, .(ccp = .N), by = .(V1, V2, V3, V6)])
      ## check if the missed circrnas have just a diferent strand
      unmatched <-
        merge(orig.est[V5 == 0],
              unfixed.bks.reads[, .(ccp = .N), by = .(V1, V2, V3, V6)],
              by = c("V1", "V2", "V3", "V6"),
              all = T)[is.na(ccp)]

      if (nrow(unmatched) > 0) {
        unmatched$V6 <- sapply(unmatched$V6, switch_strand)
        strand.switched <-
          merge(unmatched,
                bks.reads,
                by = c("V1", "V2", "V3", "V6"),
                all.y = F)[, .(V1, V2, V3,
                               V4, V5 = V5.y,
                               V6)]

        ## missed circrnas fixed by strand switch
        # nrow(strand.switched[, .(ccp = .N), by = .(V1, V2, V3, V6)])
        if (nrow(strand.switched[, .(ccp = .N), by = .(V1, V2, V3, V6)]) > 0) {
          chimout.slices$unf.str.swi <-
            strand.switched[, .(V1, V2, V3, V4, V5,
                                V6 = sapply(V6, switch_strand))]
        }

        ## check if now the matched circrnas correspond to the
        ## circexplorer-unmodified circrnas
        # nrow(orig.est[V5 == 0]) == nrow(rbindlist(list(unfixed.bks.reads,
        #                                                strand.switched),
        #                                           use.names = T)[, .(ccp = .N), by = .(V1, V2, V3, V6)])
      }
      ## now, check the circexplorer-MODIFIED circrnas

      ## number of ce2-modified circrnas
      # nrow(orig.est[V5 != 0])

      if (nrow(orig.est[V5 != 0]) > 0) {
        ## prepare tolerance intervals for coordinate fix
        ext.range <- c(-arguments$range:arguments$range)
        ext.range <- ext.range[ext.range != 0]
        unfix.orig.est <-
          orig.est[V5 != 0, .(start = V2 + ext.range,
                              end = V3 + ext.range),
                   by = .(V1, fixed.V2 = V2, fixed.V3 = V3, V6)]

        ## search the reads with the extended coordinates
        ## fixed.bks.reads will be the extended coordinates-found reads
        fixed.bks.reads <-
          merge(bks.reads,
                unfix.orig.est,
                by.x = c("V1", "V2", "V3", "V6"),
                by.y = c("V1", "start", "end",
                         "V6"))[, .(V1, V2 = fixed.V2,
                                    V3 = fixed.V3, V4,
                                    V5, V6)]

        fixed.match <-
          merge(orig.est[V5 != 0],
                fixed.bks.reads[, .N, by = .(V1, V2, V3, V6)],
                by = c("V1", "V2", "V3", "V6"),
                all = T)

        if (nrow(fixed.match[!is.na(N)]) > 0) {
          ## store fixed coordinates for reads
          chimout.slices$fix.coo <-
            merge(bks.reads,
                  unfix.orig.est,
                  by.x = c("V1", "V2", "V3", "V6"),
                  by.y = c("V1", "start", "end",
                           "V6"),
                  all = F)[, .(V1, V2 = fixed.V2,
                               V3 = fixed.V3, V4,
                               V5, V6)]
        }

        ## check if some circrna is still missed also after coordinate extension search
        still.missed <- fixed.match[is.na(N)]

        if (nrow(still.missed) > 0) {
          ## check if the still missed have a different strand in reads
          still.missed$V6 <- sapply(still.missed$V6, switch_strand)

          ## expand interval of still missed
          extended.still.missed <-
            still.missed[, .(start = V2 + ext.range,
                             end = V3 + ext.range),
                         by = .(V1, fixed.V2 = V2, fixed.V3= V3, V6)]

          still.missed.strand.switched <-
            merge(bks.reads,
                  extended.still.missed,
                  by.x = c("V1", "V2", "V3", "V6"),
                  by.y = c("V1", "start", "end",
                           "V6"))[, .(V1, V2 = fixed.V2,
                                      V3 = fixed.V3, V4,
                                      V5, V6)]

          ## missed circrnas fixed by strand switch
          if (nrow(still.missed.strand.switched[, .(ccp = .N), by = .(V1, V2, V3, V6)]) > 0) {
            ## store fixed coordinates and strand for reads
            chimout.slices$fix.coo.str <-
              merge(bks.reads,
                    extended.still.missed,
                    by.x = c("V1", "V2", "V3", "V6"),
                    by.y = c("V1", "start", "end",
                             "V6"))[, .(V1, V2 = fixed.V2,
                                        V3 = fixed.V3, V4, V5,
                                        V6 = sapply(V6, switch_strand))]
          }
        }
      }

      ## bind all reads (all.seg.bks.reads)
      # annotated.bks.reads <-
      #     rbindlist(list(unfixed.bks.reads,
      #                    strand.switched,
      #                    fixed.bks.reads,
      #                    still.missed.strand.switched),
      #               use.names = T)

      ## check the number of identified circrnas
      # nrow(orig.est) - nrow(annotated.bks.reads[, .(ccp = .N), by = .(V1, V2, V3, V6)])

      # chimout.slices <-
      #     list(unf = unfixed.bks.reads,
      #          unf.str.swi = strand.switched[, .(V1, V2, V3, V4, V5,
      #                                            V6 = sapply(V6, switch_strand))],
      #          fix.coo = merge(bks.reads,
      #                          unfix.orig.est,
      #                          by.x = c("V1", "V2", "V3", "V6"),
      #                          by.y = c("V1", "start", "end",
      #                                   "V6"),
      #                          all = F)[, .(V1, V2 = fixed.V2,
      #                                       V3 = fixed.V3, V4,
      #                                       V5, V6)],
      #          fix.coo.str = merge(bks.reads,
      #                              extended.still.missed,
      #                              by.x = c("V1", "V2", "V3", "V6"),
      #                              by.y = c("V1", "start", "end",
      #                                       "V6"))[, .(V1, V2 = fixed.V2,
      #                                                  V3 = fixed.V3, V4, V5,
      #                                                  V6 = sapply(V6, switch_strand))]
      #     )

      annotated.chimout.junc <-
        rbindlist(chimout.slices,
                  use.names = T,
                  idcol = "Set")
    }else{

      annotated.chimout.junc <- bks.reads[, .(V1, V2, V3, V4, V6)]
    }

    splitted.filename <- strsplit(arguments$output, ".", fixed = T)[[1]]
    if (tail(splitted.filename, 1) == "gz") {
      tmp.outfile <- sub(".gz$", "", arguments$output)
    }

    annotated.chimout.junc <- annotated.chimout.junc[, .(V1, V2, V3, V4, V5, V6)]

    fwrite(x = annotated.chimout.junc,
           file = tmp.outfile,
           sep = "\t",
           col.names = F,
           row.names = F)

    if (tail(splitted.filename, 1) == "gz") {
      gzip(tmp.outfile, destname = arguments$output)
    }

  }else{
    warning(paste("No circRNAs in input file", orig.file))
    file.create(arguments$output)
  }


}


get_circompara_counts <- function() {

  #------------------------------------------------------------------------------#
  #!/usr/bin/env Rscript

  suppressPackageStartupMessages(library(optparse))
  suppressPackageStartupMessages(library(data.table))

  option_list <- list(
    make_option(c("-i", "--input"), action = "store", type = "character",
                default = "circular.reads.bed.gz.txt",
                help = "File with the list of circular.reads.bed.gz files to merge, each sample and method (default: circular.reads.bed.gz.txt)"),
    make_option(c("-q", "--min_methods"), action = "store", type = "integer",
                default = 2,
                help = "Minimum number of methods (default: 2)"),
    make_option(c("-o", "--output_prefix"), action = "store", type = "character",
                default = "bks.counts.",
                help = "A prefix for output file names (default: bks.counts.intersect.csv, bks.counts.union.csv, bks.counts.union.intersected.csv)"),
    # make_option(c("-f", "--format"), action = "store", type = "character",
    #             default = "BED",
    #             help = "The file format of output files {GTF,BED}"),
    make_option(c("-s", "--stranded"), action = "store_true", default = F,
                help = "Set this option if circRNA strand has to be considered"),
    make_option(c("-c", "--circrnas_gtf"), action = "store", type = "character", default = NA,
                help = "A circrnas.gtf file or a text file listing circrnas.gtf file paths to merge"),
    make_option(c("-t", "--xprtypes"), action = "store", type = "character", default = "UN_IN_IU_MD",
                help = paste("An underscore separated list of the strategy(ies) that will be used to combine and report",
                             "the expression estimates. The options available are:",
                             "UN = combine and count all the unique backsplice junction read fragments (BJRs) from any circRNA detection method;",
                             "IN = count only the BJRs commonly identified by at least 'min_methods' methods",
                             "IU = at least 1 BJRs is required to be commonly identified by at least 'min_methods' methods, then count all other BJRs",
                             "MD = compute the median of the read count reported by each method that detected the circRNA",
                             "ME = (not yet implemented) compute the mean of the read count reported by each method that detected the circRNA"))
  )

  parser <- OptionParser(usage = "%prog -i circular.reads.bed.gz.txt -q 2 -o bks.counts.",
                         option_list = option_list,
                         description = "Compute backsplices' read counts")

  arguments <- parse_args(parser, positional_arguments = F)

  input <- arguments$input
  output_prefix <- arguments$output_prefix
  min_methods <- arguments$min_methods
  # file.ext <- tolower(arguments$format)
  file.ext <- "csv"
  stranded <- arguments$stranded
  circrnas.gtf.files <- arguments$circrnas_gtf
  strategies <- unlist(strsplit(arguments$xprtypes, split = "_"))

  circular.reads.bed.gz.txt <- readLines(input)

  ## filter out empty files
  keep <- sapply(circular.reads.bed.gz.txt, file.exists, simplify = T)
  if (any(!keep))print(paste0(circular.reads.bed.gz.txt[!keep], " skipped because not exisitng"))
  circular.reads.bed.gz.txt <- circular.reads.bed.gz.txt[keep]

  keep <- sapply(circular.reads.bed.gz.txt, function(x) {file.size(x)>0}, simplify = T)
  if (any(!keep))print(paste0(circular.reads.bed.gz.txt[!keep], " skipped because 0 size"))
  circular.reads.bed.gz.txt <- circular.reads.bed.gz.txt[keep]

  keep <- sapply(circular.reads.bed.gz.txt,
                 function(x) {length(grep("^$", x = readLines(x), invert = T))>0},
                 simplify = T)
  if (any(!keep))print(paste0(circular.reads.bed.gz.txt[!keep], " skipped because empty"))
  circular.reads.bed.gz.txt <- circular.reads.bed.gz.txt[keep]


  bks.read.method <-
    unique(rbindlist(sapply(circular.reads.bed.gz.txt, data.table::fread, header = F,
                            col.names = c("chr", "start", "end", "read_id", "score", "strand"),
                            simplify = F),
                     idcol = "sample_id")[, `:=`(sample_id = sub(".circular.reads.bed.gz", "",
                                                                 basename(sample_id)),
                                                 circ_method = sub(".+circRNAs/([^/]+)/.*", "\\1",
                                                                   sample_id))][])
  ## fix DCC coordinates
  bks.read.method[circ_method == "dcc", start := start -1L]

  ## fix possible duplicate names of reads (this will count sequenced fragments, not reads)
  ## given by "\1", "\2" mate name extension, and/or "revcomp_of_" prefix when stranded reads
  bks.read.method[, read_id := sub("\\\\[12]$", "", read_id)]
  bks.read.method[, read_id := sub("^revcomp_of_", "", read_id)]

  bks.read.method <- unique(bks.read.method)

  ## save collected reads
  filename <- paste0(output_prefix, "collected_reads.", file.ext)
  write.csv(x = bks.read.method[, .(sample_id, chr, start, end, read_id, strand, circ_method)],
            file = filename,
            row.names = F)

  ##
  if (stranded) {
    bks.reads <-
      bks.read.method[, .(n_methods = length(unique(circ_method)),
                          circ_methods = list(unique(circ_method))),
                      by = .(sample_id, chr, start, end, read_id,
                             strand)]
  }else{
    bks.reads <-
      bks.read.method[, .(n_methods = length(unique(circ_method)),
                          circ_methods = list(unique(circ_method))),
                      by = .(sample_id, chr, start, end,
                             read_id)]
  }

  if ("IN" %in% strategies) {
    ## STRATEGY A)
    ## for each backsplice, count only reads detected by >= min_methods
    ## This should improve reliability of read counts
    ## n_methods_partials: comma-separated list of read.count@n_methods.
    ##                     Example
    ##                     33@5,56@2,8@3,1@2 means that for 98 reads in total:
    ##                     - 33 reads were commonly detected by 5 methods,
    ##                     - 56 reads were commonly detected by 2 methods,
    ##                     - 8 reads were commonly detected by 3 methods,
    ##                     - 1 reads were commonly detected by 2 methods (in a different combination with respect to the other 56 reads)
    ## methods_partials: comma-separated list of read.count@method_names.
    ##                   As for n_methods_partials, giving the method names combinations
    if (stranded) {
      # bks.read.counts.intersect <-
      #     bks.reads[n_methods >= min_methods, .N,
      #               by = .(sample_id, chr, start, end, strand, methods,
      #                      n_methods)][, .(read.count = sum(N),
      #                                      n_methods_partials = paste0(paste0(N, "@", n_methods),
      #                                                                  collapse = ","),
      #                                      methods_partials = paste0(paste0(N, "@", methods),
      #                                                                collapse = ",")),
      #                                  by = .(sample_id, chr, start, end, strand)]

      bks.read.counts.intersect <-
        bks.reads[n_methods >= min_methods,
                  .(read.count = .N,
                    circ_methods = list(unique(unlist(circ_methods)))),
                  by = .(sample_id, chr, start, end,
                         strand)][, .(n_methods = length(unlist(circ_methods)),
                                      circ_methods = paste0(sort(unlist(circ_methods)),
                                                            collapse = "|")),
                                  by = .(sample_id, chr, start, end, strand,
                                         read.count)]

    }else{

      # bks.read.counts.intersect <-
      #     bks.reads[n_methods >= min_methods, .N,
      #               by = .(sample_id, chr, start, end, methods,
      #                      n_methods)][, .(read.count = sum(N),
      #                                      n_methods_partials = paste0(paste0(N, "@", n_methods),
      #                                                                  collapse = ","),
      #                                      methods_partials = paste0(paste0(N, "@", methods),
      #                                                                collapse = ",")),
      #                                  by = .(sample_id, chr, start, end)]

      bks.read.counts.intersect <-
        bks.reads[n_methods >= min_methods,
                  .(read.count = .N,
                    circ_methods = list(unique(unlist(circ_methods)))),
                  by = .(sample_id, chr, start,
                         end)][, .(n_methods = length(unlist(circ_methods)),
                                   circ_methods = paste0(sort(unlist(circ_methods)),
                                                         collapse = "|")),
                               by = .(sample_id, chr, start, end,
                                      read.count)]

    }


    filename <- paste0(output_prefix, "intersect.", file.ext)
    fwrite(x = bks.read.counts.intersect,
           file = filename,
           row.names = F, col.names = T, sep = "\t")
  }

  if ("UN" %in% strategies) {
    ## STRATEGY B)
    ## count all reads for each backsplice and keep it if >= min_methods detected
    ## any read for it, i.e: keep the backsplice and its read count if different
    ## methods detected it also if by different read ids
    ## F.i, if min_methods = 2:
    ## - keep bks Y with count "100 reads" in total: 50 reads are detected only
    ## by DCC and 50 only by CIRI, no reads detected by both methods
    ## - discard bks Z with 100 reads detected only by DCC
    ## This should improve sensibility of detection
    if (stranded) {
      bks.read.counts.union <-
        bks.reads[, .(read.count = .N,
                      circ_methods = list(unique(unlist(circ_methods)))),
                  by = .(sample_id, chr, start, end,
                         strand)][, .(n_methods = length(unlist(circ_methods)),
                                      circ_methods = paste0(sort(unlist(circ_methods)),
                                                            collapse = "|")),
                                  by = .(sample_id, chr, start, end,
                                         strand, read.count)]
      #[n_methods >= min_methods] ## do not filter already
    }else{
      bks.read.counts.union <-
        bks.reads[, .(read.count = .N,
                      circ_methods = list(unique(unlist(circ_methods)))),
                  by = .(sample_id, chr, start,
                         end)][, .(n_methods = length(unlist(circ_methods)),
                                   circ_methods = paste0(sort(unlist(circ_methods)),
                                                         collapse = "|")),
                               by = .(sample_id, chr, start, end,
                                      read.count)]
      #[n_methods >= min_methods] ## do not filter already
    }

    filename <- paste0(output_prefix, "union.", file.ext)
    fwrite(x = bks.read.counts.union,
           file = filename,
           row.names = F, col.names = T, sep = "\t")
  }

  if ("IU" %in% strategies) {
    ## STRATEGY C)
    ## for each backsplice, if one read was detected by >= min_methods then count
    ## also reads detected by < min_methods
    ## F.i, if min_methods = 2:
    ## - keep bks Y with count "100 reads" in total: 50 reads are detected only
    ## by DCC and 49 only by CIRI, plus 1 read which is detected by both methods;
    ## - discard bks Z with count "100 reads" in total: 50 reads are detected only
    ## by DCC and 50 only by CIRI, no reads detected by both methods
    if (stranded) {
      bks <- unique(bks.reads[n_methods >= min_methods, .(sample_id, chr, start, end, strand)])
      # bks.read.counts.union.intersected <-
      #     bks.reads[bks,
      #               on = c("sample_id", "chr", "start", "end",
      #                      "strand")][, .(read.count = .N),
      #                                 by = .(sample_id, chr, start, end, strand)]

      bks.read.counts.union.intersected <-
        bks.reads[bks,
                  .(read.count = .N,
                    circ_methods = list(unique(unlist(circ_methods)))),
                  by = .(sample_id, chr, start, end,
                         strand),
                  on = c("sample_id", "chr", "start",
                         "end"),
                  nomatch = NULL][, .(n_methods = length(unlist(circ_methods)),
                                      circ_methods = paste0(sort(unlist(circ_methods)),
                                                            collapse = "|")),
                                  by = .(sample_id, chr, start, end, strand,
                                         read.count)]
    }else{
      bks <- unique(bks.reads[n_methods >= min_methods, .(sample_id, chr, start, end)])
      # bks.read.counts.union.intersected <-
      #     bks.reads[bks, on = c("sample_id", "chr", "start",
      #                           "end")][, .(read.count = .N),
      #                                   by = .(sample_id, chr, start, end)]

      bks.read.counts.union.intersected <-
        bks.reads[bks,
                  .(read.count = .N,
                    circ_methods = list(unique(unlist(circ_methods)))),
                  by = .(sample_id, chr, start,
                         end),
                  on = c("sample_id", "chr", "start",
                         "end"),
                  nomatch = NULL][, .(n_methods = length(unlist(circ_methods)),
                                      circ_methods = paste0(sort(unlist(circ_methods)),
                                                            collapse = "|")),
                                  by = .(sample_id, chr, start, end,
                                         read.count)]

    }

    filename <- paste0(output_prefix, "union.intersected.", file.ext)
    fwrite(x = bks.read.counts.union.intersected,
           file = filename,
           row.names = F, col.names = T, sep = "\t")

  }


  # ## save in a matrix-like format
  # bks.read.counts <- bks.read.counts.union
  # bks.read.counts.wide <-
  #     dcast(data = bks.read.counts,
  #           formula = chr + start + end + strand ~ sample_id,
  #           value.var = "read.count",
  #           fill = 0)
  #
  # filename <- paste0(output_prefix, "")
  # write.csv(x = ,
  #           file = filename,
  #           row.names = F)

  if ("MD" %in% strategies) {
    if (!is.na(circrnas.gtf.files)) {
      if (ncol(fread(circrnas.gtf.files, showProgress = F, nrows = 1)) == 1) {
        ## case: text file listing circrnas.gtf files
        circrnas.gtf.files <- readLines(circrnas.gtf.files)
      }

      ## read circRNA results: filter low expressed (less than min_reads reads) circRNAs
      colClasses <- c("factor", "factor", "character", "integer",
                      "integer", "integer", "factor", "character", "character")
      circrnas.gtf <- rbindlist(lapply(circrnas.gtf.files, data.table::fread, data.table = T,
                                       colClasses = colClasses, showProgress = F),
                                use.names = T)

      if (stranded) {
        circrnas.gtf[, `:=` (sample_id = sub('.*sample_id "([^"]*)".*', "\\1", V9),
                             circ_id = paste0(V1, ":", V4-1, "-", V5, ":", V7))][, V9 := NULL]

        ## sumup expression by circ_id (within the same detection method and sample)
        circrnas.gtf <-
          circrnas.gtf[, .(V6 = sum(V6)),
                       by = .(V1, V2, V4, V5, V7, sample_id, circ_id)]
      }else{
        circrnas.gtf[, `:=` (sample_id = sub('.*sample_id "([^"]*)".*', "\\1", V9),
                             circ_id = paste0(V1, ":", V4-1, "-", V5))][, V9 := NULL]

        ## sumup expression by circ_id (within the same detection method and sample)
        circrnas.gtf <-
          circrnas.gtf[, .(V6 = sum(V6)),
                       by = .(V1, V2, V4, V5, sample_id, circ_id)]
      }
      circrna.median.reads <-
        circrnas.gtf[, .(read.count = as.numeric(median(V6)),
                         n_methods = length(unique(V2)),
                         circ_methods = paste0(sort(unique(V2)),
                                               collapse = "|")),
                     by = .(sample_id, circ_id)]

      filename <- paste0(output_prefix, "median.", file.ext)
      fwrite(x = circrna.median.reads,
             file = filename,
             row.names = F, col.names = T, sep = "\t")
    }
  }


}

get_circrnaFinder_bks_reads <- function() {

  #------------------------------------------------------------------------------#
  #!/usr/bin/env Rscript

  suppressPackageStartupMessages(library(optparse))
  suppressPackageStartupMessages(library(data.table))
  suppressPackageStartupMessages(library(R.utils))

  option_list <- list(
    make_option(c("-r", "--chimreads"), action="store", type="character",
                help="Chimeric.out.junction BED filtered and formatted by cf_filterChimout.awk"),
    make_option(c("-c", "--circrnas"), action="store", type="character",
                help="circularRNA_known.txt as output by CIRCexplorer2 annotate, or back_spliced_junction.bed as output by CIRCexplorer2 parse"),
    make_option(c("-o", "--output"), action="store", type="character",
                help="The circRNA read IDs for each circRNA in compressed BED (circular.reads.bed.gz)")
  )

  parser <-
    OptionParser(usage="%prog -r cf.filtered.Chimeric.out.junction -c filteredJunctions.bed -o circular.reads.bed.gz",
                 option_list=option_list)
  arguments <- parse_args(parser, positional_arguments=F)

  orig.file <- arguments$circrnas

  if (file.info(orig.file)$size > 0) {

    orig.est <- fread(orig.file)[, .(orig = sum(V5)), by = .(V1, V2, V3, V6), ]
    orig.est$V1 <- as.character(orig.est$V1)

    ## process the Chimeric.out.junction entries filtered as circrna_finder does:
    ## see https://github.com/orzechoj/circRNA_finder/blob/master/filterCirc.awk
    ## Assume chimeric reads pre-processed by the cf_filterChimout.awk form CirComPara

    chimout.file <- arguments$chimreads
    chimout.junc.bed <- fread(chimout.file, verbose = F,
                              showProgress = F, header = F)
    chimout.junc.bed$V1 <- as.character(chimout.junc.bed$V1)

    filterd.chimout.junc <-
      merge(chimout.junc.bed,
            orig.est[, .(V1, V2, V3, V6)],
            by = c("V1", "V2", "V3", "V6"),
            all.x = F,
            all.y = T)[, .(V1, V2, V3, V4, V5, V6)]

    splitted.filename <- strsplit(arguments$output, ".", fixed = T)[[1]]
    if (tail(splitted.filename, 1) == "gz") {
      tmp.outfile <- sub(".gz$", "", arguments$output)
    }

    fwrite(x = filterd.chimout.junc,
           file = tmp.outfile,
           sep = "\t",
           col.names = F,
           row.names = F)

    if (tail(splitted.filename, 1) == "gz") {
      gzip(tmp.outfile, destname = arguments$output)
    }

  }else{
    warning(paste("No circRNAs in input file", orig.file))
    file.create(arguments$output)
  }


}

get_ciri_bks_reads <- function() {

  #------------------------------------------------------------------------------#
  #!/usr/bin/env Rscript

  suppressPackageStartupMessages(library(optparse))
  suppressPackageStartupMessages(library(data.table))

  option_list <- list(
    make_option(c("-i", "--input"), action = "store", type = "character",
                default = "ciri.out",
                help = "CIRI2 output file (default: ciri.out)"),
    make_option(c("-b", "--reads_bed"), action = "store", type = "character",
                default = "circular.reads.bed.gz",
                help = "Output filename of BED file with read IDs for each backsplice (default: circular.reads.bed.gz)"),
    make_option(c("-l", "--read_list"), action = "store", type = "character",
                default = "bks.reads",
                help = "Output filename of all read ID list (default: bks.reads)")
  )

  parser <- OptionParser(usage = "%prog -i ciri.out -b circular.reads.bed.gz -l bks.reads",
                         option_list = option_list,
                         description = "")

  arguments <- parse_args(parser, positional_arguments = F)

  input <- arguments$input
  reads.bed <- arguments$reads_bed
  read.list <- arguments$read_list

  # input <- "/blackhole/enrico/circular/circompara_testing/circompara/test_circompara/analysis/samples/sample_A/processings/circRNAs/ciri_out/sample_A_ciri.out"

  ## N.B: CIRI output is 1-based as GTFs.
  ## We need to decrease start position to comply with BED format
  ciri.out <- fread(input = input, select = c(2,3,4,11,12), showProgress = F)[, circRNA_start := circRNA_start - 1]

  bks.reads <- data.table()
  all.reads <- data.table()

  if (nrow(ciri.out) > 0) {

    ## method jaap_DT2 from
    ## https://stackoverflow.com/questions/13773770/split-comma-separated-strings-in-a-column-into-separate-rows
    bks.reads <-
      ciri.out[, strsplit(as.character(junction_reads_ID), ",", fixed = T),
               by = .(chr, circRNA_start, circRNA_end, strand,
                      junction_reads_ID)][, .(chr, circRNA_start, circRNA_end,
                                              read_id = V1, score = 0, strand)]

    all.reads <-
      bks.reads[, .N, by = read_id][order(-N), .(N, read_id)]

  }else{
    warning(paste("No circRNAs in input file", input))
  }

  ## write gzipped file for circular reads
  reads_output.gz <- gzfile(reads.bed, "w")
  write.table(bks.reads, file = reads_output.gz,
              sep = "\t", col.names = F, row.names = F, quote = F)
  close(reads_output.gz)

  write.table(all.reads, file = read.list,
              sep = "\t", col.names = F, row.names = F, quote = F)


}

get_dcc_bks_reads <- function() {

  #------------------------------------------------------------------------------#
  #!/usr/bin/env Rscript

  suppressPackageStartupMessages(library(optparse))
  suppressPackageStartupMessages(library(data.table))
  suppressPackageStartupMessages(library(R.utils))

  option_list <- list(
    make_option(c("-r", "--chimreads"), action="store", type="character",
                help="Chimeric.out.junction BED transformed by chimout_junc_to_bed.py"),
    make_option(c("-c", "--circrnas"), action="store", type="character",
                help="circularRNA_known.txt as output by CIRCexplorer2 annotate, or back_spliced_junction.bed as output by CIRCexplorer2 parse"),
    make_option(c("-o", "--output"), action="store", type="character",
                help="The circRNA read IDs for each circRNA in compressed BED (circular.reads.bed.gz)"),
    make_option(c("-t", "--tolerance"), action="store", type="integer", default = 5,
                help="Number of basepairs tolerated in realigning circRNAs from CIRCexplorer2 annotate"),
    make_option(c("-s", "--stranded"), action="store_true", default = FALSE,
                help="Set if stranded library")
  )

  parser <-
    OptionParser(usage="%prog -r Chimeric.out.junction -c strandedCircRNACount -g 10 -o circular.reads.bed.gz",
                 option_list=option_list)
  arguments <- parse_args(parser, positional_arguments=F)

  orig.file <- arguments$circrnas

  if (file.info(orig.file)$size > 0) {

    orig.est <- fread(file = orig.file)[, .(V1 = as.character(Chr), V2 = Start, V3 = End,
                                            orig = Chimeric.out.junction, V6 = Strand), ]

    ## process the Chimeric.out.junction entries as DCC does:
    ## see https://github.com/dieterich-lab/DCC/blob/master/DCC/findcircRNA.py
    ## findcirc and cigarGenomicDist functions

    ## read the file and keep only rows in which
    ## 1. chromosome of the segments is the same
    ## 2. strand of the segments is the same
    chimout.file <- arguments$chimreads
    chimout <- fread(chimout.file, verbose = F,
                     showProgress = F, header = F)[V1 == V4 & V3 == V6 & V7 >= 0]
    chimout$V1 <- as.character(chimout$V1)

    cigar_dist <- function(cigar.str) {
      cigar.split <- strsplit(cigar.str, "")[[1]]
      C <- grep('[a-zA-Z]', cigar.split, value = T)
      L <- gregexpr('-?[0-9]+', cigar.str)
      g <- 0
      for(i in 1:length(L[[1]])) {
        if (C[i] != 'S' & C[i] != "I") {
          g <- g + as.integer(paste0(cigar.split[L[[1]][i]:(L[[1]][i]+attr(L[[1]],
                                                                           "match.length")[i]-1)],
                                     collapse = ""))
        }
      }
      g
    }

    chimout[, `:=`(V14.cigar.dist = sapply(V14, cigar_dist),
                   V12.cigar.dist = sapply(V12, cigar_dist))]
    ## check orientation of segment alignement:
    ## if + strand then first segment comes after second segment, first->second if - strand
    ## Mind the length of aligned segment, and tolerance (5 bases default)

    tolerance <- arguments$tolerance

    chimout.junc.bed <-
      rbindlist(list(chimout[V3 == "+" & V11 + tolerance > V5 & (V13 - tolerance) + V14.cigar.dist <= V2],
                     chimout[V3 == "-" & V13 + tolerance > V2 & (V11 - tolerance) + V12.cigar.dist <= V5]),
                use.names = T)

    ## swap start/end if + strand
    chimout.junc.bed[V3 == "+", `:=`(tmp = V2, V2 = V5)][V3 == "+", V5 := tmp]

    ## prepare BED coordinates:
    ## Chimeric.out.junction coordinates are 1-based, but refer to the intron first position
    ## add 1 to start (acceptor intron base) and remove 1 to end (donor intron base)
    chimout.junc.bed <-
      chimout.junc.bed[, .(V1, V2 = V2 + 1, V3 = V5 - 1, V4 = V10, V5 = V7, V6 = V3)]

    strand <- arguments$stranded
    # invert.strand <- function(s) {
    #     if (s == "+") {
    #         s <- "-"
    #     }else{
    #         s <- "+"
    #     }
    #     s
    # }

    if (strand) {
      # chimout.junc.bed[, V6 := sapply(V6, invert.strand)]

      filterd.chimout.junc <-
        merge(chimout.junc.bed,
              orig.est[, .(V1, V2, V3, V6)],
              by = c("V1", "V2", "V3", "V6"),
              all.x = F,
              all.y = T)[, .(V1, V2, V3, V4, V5, V6)]
    }else{
      filterd.chimout.junc <-
        merge(chimout.junc.bed,
              orig.est[, .(V1, V2, V3)],
              by = c("V1", "V2", "V3"),
              all.x = F,
              all.y = T)[, .(V1, V2, V3, V4, V5, V6)]
    }

    splitted.filename <- strsplit(arguments$output, ".", fixed = T)[[1]]
    if (tail(splitted.filename, 1) == "gz") {
      tmp.outfile <- sub(".gz$", "", arguments$output)
    }

    fwrite(x = filterd.chimout.junc,
           file = tmp.outfile,
           sep = "\t",
           col.names = F,
           row.names = F)

    if (tail(splitted.filename, 1) == "gz") {
      gzip(tmp.outfile, destname = arguments$output)
    }
  }else{
    warning(paste("No circRNAs in input file", orig.file))
    file.create(arguments$output)
  }


}


get_findcirc_bks_reads <- function() {

  #------------------------------------------------------------------------------#
  #!/usr/bin/env Rscript

  suppressPackageStartupMessages(library(optparse))
  suppressPackageStartupMessages(library(data.table))

  option_list <- list(
    make_option(c("-s", "--sites_reads"), action = "store", type = "character",
                default = "sites.reads",
                help = "Read file (in FASTA format) as the ouput by -R option of find_circ.py (default: sites.reads)"),
    make_option(c("-c", "--circ_candidates"), action = "store", type = "character",
                default = "circ_candidates.bed",
                help = "BED file with backsplices, as find_circ.py main output (default: circ_candidates.bed)"),
    make_option(c("-r", "--reads_bed"), action = "store", type = "character",
                default = "circular.reads.bed.gz",
                help = "Output filename of BED file with read IDs for each backsplice (default: circular.reads.bed.gz)"),
    make_option(c("-l", "--read_list"), action = "store", type = "character",
                default = "bks.reads",
                help = "Output filename of all read ID list (default: bks.reads)")
  )

  parser <- OptionParser(usage = "%prog -i ciri.out -b circular.reads.bed.gz -l bks.reads",
                         option_list = option_list,
                         description = "")

  arguments <- parse_args(parser, positional_arguments = F)

  sites.reads.file <- arguments$sites_reads
  circ.candidates.bed.file <- arguments$circ_candidates
  reads.bed <- arguments$reads_bed
  read.list <- arguments$read_list

  # sites.reads.file <- "/blackhole/enrico/circular/circompara_testing/circompara/test_circompara/analysis/samples/sample_A/processings/circRNAs/find_circ_out/sites.reads"
  # circ.candidates.bed.file <- "/blackhole/enrico/circular/circompara_testing/circompara/test_circompara/analysis/samples/sample_A/processings/circRNAs/find_circ_out/circ_candidates.bed"

  sites.reads <-
    fread(cmd = paste0('grep ">" ', sites.reads.file),
          sep = " ",
          header = F)[, .(V4 = sub(">", "", V1),
                          read_id = sub("(.*)_([0-9]+)", "\\1", V2))]

  circ.candidates.bed <- fread(input = circ.candidates.bed.file,
                               header = F, select = c(1, 2, 3, 4, 5, 6))

  bks.reads <- data.table()
  all.reads <- data.table()

  if (nrow(circ.candidates.bed) > 0 & nrow(sites.reads) > 0) {
    bks.reads <- merge(sites.reads, circ.candidates.bed,
                       by = "V4", all.x = F,
                       all.y = T)[, .(V1, V2, V3, read_id, V5, V6)]

    all.reads <-
      bks.reads[, .N, by = read_id][order(-N), .(N, read_id)]
  }else{
    if (nrow(circ.candidates.bed) == 0) {
      warning(paste("No circRNAs in input file", circ.candidates.bed.file))
    }
    if (nrow(sites.reads) == 0) {
      warning(paste("No reads in input file", sites.reads.file))
    }
  }

  ## write gzipped file for circular reads
  reads_output.gz <- gzfile(reads.bed, "w")
  write.table(bks.reads, file = reads_output.gz,
              sep = "\t", col.names = F, row.names = F, quote = F)
  close(reads_output.gz)

  write.table(all.reads, file = read.list,
              sep = "\t", col.names = F, row.names = F, quote = F)


}


get_gene_expression_files <- function() {

  #------------------------------------------------------------------------------#
  #!/usr/bin/env Rscript

  suppressPackageStartupMessages(library(optparse))
  suppressPackageStartupMessages(library(data.table))

  option_list <- list(
    make_option(c("-o", "--results.dir"), action = "store", type = "character",
                default = "./",
                help = "The output directory path"),
    make_option(c("-t", "--transcripts.gtf.files"), action = "store", type = "character",
                # default = "",
                help = "The transcripts.gtf files as output by Stringtie"),
    make_option(c("-r", "--gene_raw_counts_list"), action = "store", type = "character",
                # default = "",
                help = ""),
    make_option(c("-g", "--gene.xpr.file"), action = "store", type = "character",
                # default = "",
                help = ""),
    make_option(c("-x", "--trx_raw_counts_list"), action = "store", type = "character",
                # default = "",
                help = "")
  )

  parser <- OptionParser(usage = "%prog ",
                         option_list = option_list,
                         description = "")

  arguments <- parse_args(parser, positional_arguments = F)

  results.dir             <- arguments$results.dir
  gene.xpr.file           <- readLines(arguments$gene.xpr.file)
  transcripts.gtf.files   <- readLines(arguments$transcripts.gtf.files)
  gene_raw_counts_list    <- readLines(arguments$gene_raw_counts_list)
  trx_raw_counts_list     <- readLines(arguments$trx_raw_counts_list)

  ## assume input is from StringTie

  gene.xpr.list <- lapply(gene.xpr.file, data.table::fread)
  names(gene.xpr.list) <- sub("_gene_abund.tab", "",
                              sapply(gene.xpr.file, basename,
                                     USE.NAMES = F))
  gene.xpr <- rbindlist(gene.xpr.list, use.names = T, idcol = "sample")

  ## TPM
  gene.xpr.tpm <- dcast(data = gene.xpr,
                        formula = `Gene ID` + `Gene Name` + Reference + Strand + Start + End ~ sample,
                        value.var = "TPM",
                        fill = 0)

  fwrite(x = gene.xpr.tpm,
         file = file.path(results.dir, "gene_expression_TPM_table.csv"),
         sep = "\t",
         col.names = T,
         row.names = F)

  ## N reads (a.k.a. coverage)
  gene.xpr.nreads <- dcast(data = gene.xpr,
                           formula = `Gene ID` + `Gene Name` + Reference + Strand + Start + End ~ sample,
                           value.var = "Coverage",
                           fill = 0)
  fwrite(x = gene.xpr.nreads,
         file = file.path(results.dir, "gene_expression_Nreads_table.csv"),
         sep = "\t",
         col.names = T,
         row.names = F)

  genes.read_group_tracking <- gene.xpr[, .(sample_id = sample, tracking_id = `Gene ID`, FPKM)]

  ## merge gene_raw_counts_list
  gene_raw_counts <- lapply(gene_raw_counts_list, data.table::fread)
  names(gene_raw_counts) <- sub("_gene_expression_rawcounts.csv", "",
                                sapply(gene_raw_counts_list, basename,
                                       USE.NAMES = F))
  gene_raw_counts <- rbindlist(gene_raw_counts, use.names = T, idcol = "sample_id")

  fwrite(x = dcast(gene_raw_counts,
                   formula = gene_id ~ sample_id,
                   value.var = "raw.reads",
                   fill = 0),
         file = file.path(results.dir, "gene_expression_rawcounts_table.csv"),
         sep = "\t",
         col.names = T,
         row.names = F)

  ## merge trx_raw_counts_list
  trx_raw_counts <- lapply(trx_raw_counts_list, data.table::fread)
  names(trx_raw_counts) <- sub("_transcript_expression_rawcounts.csv", "",
                               sapply(trx_raw_counts_list, basename,
                                      USE.NAMES = F))
  trx_raw_counts <- rbindlist(trx_raw_counts, use.names = T, idcol = "sample_id")

  fwrite(x = dcast(trx_raw_counts[raw.reads > 0, ],
                   formula = gene_id + transcript_id ~ sample_id,
                   value.var = "raw.reads",
                   fill = 0),
         file = file.path(results.dir, "transcript_expression_rawcounts_table.csv"),
         sep = "\t",
         col.names = T,
         row.names = F)

  # expressed_genes <- genes.read_group_tracking[, FPKM := round(FPKM, digits = 8)][FPKM > 0]

  gene.xpr.fpkm <-
    dcast(data = gene.xpr,
          formula = `Gene ID` + `Gene Name` + Reference + Strand + Start + End ~ sample,
          value.var = "FPKM",
          fill = 0)

  colnames(gene.xpr.fpkm)[colnames(gene.xpr.fpkm) == "Gene ID"] <- "gene"

  gene.xpr.fpkm <-
    gene.xpr.fpkm[, `:=`("Gene Name" = NULL,
                         "Reference"= NULL,
                         "Strand" = NULL,
                         "Start" = NULL,
                         "End" = NULL)][]

  expressed_genes_table.file <- file.path(results.dir, "gene_expression_FPKM_table.csv")
  fwrite(x = gene.xpr.fpkm,
         file = expressed_genes_table.file,
         row.names = F,
         col.names = T,
         sep = "\t")


}

get_stringtie_rawcounts <- function() {

  #------------------------------------------------------------------------------#
  #!/usr/bin/env Rscript

  suppressPackageStartupMessages(library(optparse))
  suppressPackageStartupMessages(library(data.table))

  option_list <- list(
    make_option(c("-g", "--transcripts_gtf"), action = "store", type = "character",
                help = "The _transcripts.gtf file output by StringTie"),
    make_option(c("-f", "--fastqc_data"), action = "store", type = "character",
                help = paste0("The fastqc_data.txt output by FastQC, or a comma ",
                              "separated list of fastqc_data.txt files if paired-end reads. ",
                              "If a number is given then it will be interpreted as the ",
                              "(already computed) average read length"),
                default = "100"),
    make_option(c("-o", "--outprefix"), action = "store", type = "character",
                help = "The prefix of output file names", default = "")

  )

  parser <- OptionParser(usage = "%prog -g sample_transcripts.gtf -f sample_R1/fastqc_data.txt,sample_R2/fastqc_data.txt",
                         description = paste0("Computes the raw read counts for both transcripts and genes ",
                                              "like the prepDE.py script from StringTie. ",
                                              "It will output two files: the transcripts' and the genes' ",
                                              "raw read counts."),
                         option_list = option_list)
  opt <- parse_args(object = parser, print_help_and_exit = T,
                    positional_arguments = F,
                    convert_hyphens_to_underscores = F)

  ## This function parses a fastqc_data.txt file and computes the average read length
  ## TODO: improve by parsing "fastqc_data.txt" and get the mode instead of average read length
  get.avg.read.len <- function(fastqc_data.txt.file) {
    fastqc_data.txt <- readLines(fastqc_data.txt.file)
    mean(as.numeric(strsplit(strsplit(grep("Sequence length",
                                           x = fastqc_data.txt,
                                           value = T),
                                      "\t")[[1]][2], "-")[[1]]))
  }

  sample_transcripts.gtf.file <- opt$transcripts_gtf
  fastqc_data.txt.files <- opt$fastqc_data

  ## as in prepDE.py script describeed in StringTie manual, compute raw read counts from
  ## the 'cov' field. We need the average read length
  if (suppressWarnings(is.na(as.numeric(fastqc_data.txt.files)))) {
    avg_read_len <- mean(sapply(strsplit(fastqc_data.txt.files, ",")[[1]], get.avg.read.len))
  }else{
    avg_read_len <- as.numeric(fastqc_data.txt.files)
  }

  ## give a message on the average read length used
  message(paste0("Average read length = ", avg_read_len))

  sample_transcripts.gtf <- fread(sample_transcripts.gtf.file, skip = 2)

  ## get cov, transcript and gene id for each exon and compute exon length
  exon.cov <- sample_transcripts.gtf[V3 == "exon",
                                     .(gene_id = sub('.*gene_id "([^"]+)".*', '\\1', V9),
                                       transcript_id = sub('.*transcript_id "([^"]+)".*', '\\1', V9),
                                       exon_number = sub('.*exon_number "([^"]+)".*', '\\1', V9),
                                       len = V5 - V4 + 1,
                                       cov = sub('.*cov "([^"]+)".*', '\\1', V9))]

  ## transcript raw count is computed by multiplying the cov (= average read count
  ## for each nucleotide) by the transcript length (sum of exons' length) and
  ## divide by average read length
  transcript.cov <-
    exon.cov[, .(len = sum(len), cov = sum(as.numeric(cov))),
             by = .(gene_id, transcript_id)][, raw.reads := ceiling(cov*len/avg_read_len),
                                             by = .(gene_id, transcript_id)][]

  write.csv(x = transcript.cov,
            file = paste0(opt$outprefix, "transcript_expression_rawcounts.csv"),
            row.names = F)

  ## gene raw count is computed as the sum of its transcripts' raw counts
  ## (prepDE.py seems not to merge overlapping exons)
  gene.cov <- transcript.cov[, .(raw.reads = sum(raw.reads)),
                             by = .(gene_id)]

  write.csv(x = gene.cov,
            file = paste0(opt$outprefix, "gene_expression_rawcounts.csv"),
            row.names = F)


}

#' Title
#'
#' @return
#' @export
#'
#' @examples
collect_read_stats <- function() {

  #------------------------------------------------------------------------------#
  # option_list <- list(
  #   make_option(c("-o", "--results.dir"), action = "store", type = "character",
  #               default = "./",
  #               help = "The output directory path"),
  #   make_option(c("-r", "--read_stats_collect.file"), action = "store", type = "character",
  #               # default = NA,
  #               help = "Read statistic files generated by parsing FASTQC and (optionally) the linear aligner log files."),
  #   make_option(c("-c", "--circrna.reads.stats.file"), action = "store", type = "character",
  #               default = NA,
  #               help = ""),
  #   make_option(c("-l", "--linear.mapper"), action = "store", type = "character",
  #               default = "hisat2",
  #               help = "The linear read aligner applied")
  # )

  results.dir <- arguments$results.dir
  read_stats_collect.file <- arguments$read_stats_collect.file
  circrna.reads.stats.file <- arguments$circrna.reads.stats.file
  linear.mapper <- arguments$linear.mapper

  read_stats_collect <-
    as.data.table(data.frame(line = cbind(scan(file = read_stats_collect.file,
                                               what = "character",
                                               multi.line = T, sep = "\n",
                                               quiet = T)),
                             stringsAsFactors = F))
  ## samples
  read_stats_collect$Sample <- gsub(pattern = paste(".*samples", "([^", "]*)", ".*",
                                                    sep = .Platform$file.sep),
                                    replacement = "\\1",
                                    x = read_stats_collect$line)

  ## preprocessing
  read_stats_collect$is.preprocessor <- grepl(pattern = "preprocess",
                                              x = read_stats_collect$line)

  read_stats_collect[is.preprocessor == TRUE,
                     preprocessor := gsub(pattern = paste("samples/[^",
                                                          "]*/processings/preprocess/([^",
                                                          "]*)",  ".*",
                                                          sep = .Platform$file.sep),
                                          replacement = "\\1",
                                          x = line)]

  if (any(read_stats_collect$is.preprocessor)) {
    read_stats_collect[is.preprocessor == TRUE,
                       `:=`(`Raw reads` = as.integer(sub(pattern = ".*Input Read[^:]*: ([0-9]*) .*Surviving.*",
                                                         "\\1", line)),
                            `Clean reads` = as.integer(sub(pattern = ".*Input Read[^:]*: [0-9]* [^0-9]* ([0-9]*) .*",
                                                           "\\1",
                                                           line)))][, Dropped := `Raw reads`- `Clean reads`]
  }else{
    ## no read preprocessing
    read_stats_collect[grepl("Total Sequences", line),
                       `:=`(is.preprocessor = T,
                            `Raw reads` = sapply(line, function(x)as.integer(strsplit(x, "\t")[[1]][2])))]
    read_stats_collect[grepl("Total Sequences", line),
                       `:=`(`Clean reads` = `Raw reads`,
                            Dropped = 0L)]
  }

  ## linearly unmapped
  read_stats_collect[, is.mapper := grepl(pattern = linear.mapper, x = line)]
  read_stats_collect[is.mapper == TRUE, `:=`(`Linearly unmapped` = ifelse(grepl(pattern = "aligned[^0]* 0 times",
                                                                                x = line),
                                                                          sub(pattern = ".* ([0-9]*) .*aligned[^0]* 0 times",
                                                                              "\\1", x = line),
                                                                          NA))]
  read_stats_collect[, `Linearly unmapped` := as.integer(`Linearly unmapped`)]

  read_stats_collect$paired = F
  read_stats_collect[grepl("were paired", line), paired := T]
  read_stats_collect[Sample %in% read_stats_collect[paired == T, Sample],
                     paired := T]

  read_stats_collect[paired == T,
                     `:=`(`Raw reads` = 2L*`Raw reads`,
                          `Clean reads` = 2L*`Clean reads`,
                          Dropped = 2L*Dropped,
                          `Linearly unmapped` = 2L*`Linearly unmapped`)]

  ## merge table
  read.processing.table <- merge(unique(read_stats_collect[is.preprocessor == TRUE,
                                                           .(Sample, `Raw reads`, `Clean reads`, Dropped)])[!is.na(`Raw reads`)],
                                 read_stats_collect[is.mapper == TRUE, ][!is.na(`Linearly unmapped`),
                                                                         .(Sample, `Linearly unmapped`)],
                                 all = T)

  if (all(is.na(read.processing.table$`Linearly unmapped`))) {
    ## possible skip linear mapping mode
    read.processing.table$`Linearly unmapped` <- read.processing.table$`Raw reads`
  }

  read.processing.table[, `Linearly mapped` := `Clean reads`-`Linearly unmapped`]

  read.processing.table.m <- data.table::melt(read.processing.table, id.vars = "Sample",
                                              variable.name = "Processing step",
                                              value.name = "Read count")
  read.processing.table.m$`Processing step` <- factor(x = read.processing.table.m$`Processing step`,
                                                      levels = c("Raw reads", "Dropped",
                                                                 "Clean reads", "Linearly mapped",
                                                                 "Linearly unmapped"),
                                                      ordered = T)

  # Circular RNA methods' alignments
  if (is.na(circrna.reads.stats.file)) {
    # if (file.info(circrna.reads.stats.file)$size == 0) {
    sum.tab <- read.processing.table
    message <- "CircRNA detection was not performed"
    print(message)
  }else{
    circrna.mappings <- fread(cmd = paste0("zcat ", circrna.reads.stats.file),
                              showProgress = F, fill = T, sep = "\t")[, .(V1, V2, V3)]
    colnames(circrna.mappings) <- c("file", "alignments", "readname")

    circrna.mappings[, `:=`(Sample = file_path_sans_ext(basename(file)),
                            `CircRNA method` = file_ext(file))]
    circrna.mappings <- circrna.mappings[, .(`Mapped reads` = .N) ,
                                         by = .(Sample, `CircRNA method`)][order(`CircRNA method`, Sample)]

    circrna.mappings.table.m <- rbind(circrna.mappings[, .(Sample, `CircRNA method`, `Mapped reads`)],
                                      read.processing.table.m[`Processing step` == "Linearly unmapped",
                                                              .(Sample, `CircRNA method` = `Processing step`,
                                                                `Mapped reads` = `Read count`)], use.names = T, fill = T)
    circrna.mappings.table <-
      dcast(data = circrna.mappings.table.m[, .(`Mapped reads`, Sample, `CircRNA method`)],
            formula = Sample ~ `CircRNA method`,
            value.var = "Mapped reads")

    if (nrow(circrna.mappings) > 0) {
      sum.tab <-
        merge(read.processing.table,
              dcast(circrna.mappings[, .(Sample, `CircRNA method`, `Mapped reads`)],
                    formula = Sample ~ `CircRNA method`,
                    value.var = "Mapped reads"))
    }else{
      sum.tab <- read.processing.table
    }
  }

  fwrite(x = sum.tab,
         file = file.path(results.dir, "processing_and_mapped_read_counts.csv"),
         sep = "\t",
         col.names = T,
         row.names = F)

}


gene_annotation <- function() {

  #------------------------------------------------------------------------------#
  #!/usr/bin/env Rscript

  suppressPackageStartupMessages(library(optparse))
  suppressPackageStartupMessages(library(data.table))
  suppressPackageStartupMessages(library(bedr))

  option_list <- list(
    make_option(c("-c", "--combined_circrnas"), action = "store", type = "character",
                help="combined_circrnas.gtf.gz"),
    make_option(c("-d", "--cluster_dist"), action = "store", type = "integer",
                default = 5000L,
                help="The maximum distance allowed to cluster intergenic circRNAs"),
    make_option(c("-o", "--outdir"), action = "store", type = "character",
                default = "./",
                help="Output directory were circ_to_genes.tsv and gene_to_circ.tsv will be saved")
  )

  parser <- OptionParser(usage="%prog -c circular_expression/circRNA_collection/combined_circrnas.gtf.gz -d 5000 -o ../circular_expression/circRNA_collection",
                         option_list=option_list)
  arguments <- parse_args(parser, positional_arguments=F)

  gene.annotation.file <- arguments$combined_circrnas
  max.dist <- arguments$cluster_dist
  ## prepare result dir
  results.path <- arguments$outdir

  dir.create(path = results.path, recursive = T, showWarnings = F)

  paste.bar <- function(x) {
    sapply(x, function(y) {
      paste0(sort(y), collapse = "|")},
      simplify = T, USE.NAMES = F)
  }

  simplify.gene.region <- function(x) {
    label <- "unknown"
    if (grepl("exon", x)) {
      label <- "exon"
    }else{
      if (grepl("intron", x)) {
        label <- "intron"
      }else{
        if (grepl("intergenic", x)) {
          label <- "intergenic"
        }
      }
    }
    label
  }

  simplify.gene.region.list <- function(x) {
    label <- "unknown"
    if ("exon" %in% x) {
      label <- "exon"
    }else{
      if ("intron" %in% x) {
        label <- "intron"
      }else{
        if ("intergenic" %in% x) {
          label <- "intergenic"
        }
      }
    }
    label
  }

  ## function to cluster intergenic circrnas
  ## intergenic.circs.bed is a data.table in BED format
  get.circ.cluster <- function(intergenic.circs.bed, max.dist = 5000L) {
    fw.strand.interg.circ <-
      intergenic.circs.bed[, paste0(chr, ":", start, "-", end)]
    circ.clusters <- data.table(cluster.region(fw.strand.interg.circ,
                                               distance = max.dist,
                                               check.chr = F, verbose = F))

    circ.clusters[, .(circ_id = index, cluster = regionIndex)]
  }

  ## get gene annotation
  if (ncol(fread(gene.annotation.file, showProgress = F, nrows = 1)) == 1) {
    ## case: text file listing combined_circrnas.gtf.gz files
    gene.annotation.file <- readLines(gene.annotation.file)
    gene.annotation <- unique(rbindlist(lapply(gene.annotation.file, data.table::fread,
                                               showProgress = F),
                                        use.names = T))
  }else{
    gene.annotation <- fread(gene.annotation.file)
  }

  gene.annotation[V12 == ".", V12 := "intergenic"]

  gene.annotation[, `:=`(circ_id = sub('.*gene_id "([^"]+)".*', "\\1", V9),
                         gene_id = sub('.*gene_id "([^"]+)".*', "\\1", V18),
                         gene_name = sub('.*gene_name "([^"]+)".*', "\\1", V18))]

  ## get circ_ids in BED coordinates
  gene.annotation[, c("chr", "start", "end",
                      "strand"):=tstrsplit(circ_id,
                                           ":|-",
                                           type.convert = T)][, circ_id := paste0(chr, ":",
                                                                                  start-1, "-", end)]

  if (grepl("gene_[bio]*type", gene.annotation$V18[1])) {
    gene.annotation[, gene_biotype := sub('.*gene_[bio]*type "([^"]+)".*', "\\1", V18)]
  }else{
    gene.annotation[, gene_biotype := "."]
  }


  # ## collapse/remove circ_id strand
  # gene.annotation[, circ_id := sub(":[+-]$", "", circ_id)]

  ## CIRCRNA TO GENES
  ## make a table with all circrna ids in one column, one per row, and
  ## the corresponding genes in a side column, in a bar-separated list.
  ### first, compose the circ -> gene-list table
  circ_to_genelist <-
    unique(gene.annotation[, .(circ_id, gene_id, gene_name,
                               gene_biotype,
                               gene_region = V12,
                               gene_strand = V16,
                               circ_strand = V7)])[, .(gene_ids = list(unique(gene_id)),
                                                       gene_names = list(unique(gene_name)),
                                                       gene_biotypes = list(unique(gene_biotype)),
                                                       gene_region = list(unique(gene_region)),
                                                       gene_strand = list(unique(gene_strand))),
                                                   by = .(circ_id, circ_strand)]
  circ_to_genelist[, simple_gene_region := sapply(gene_region, simplify.gene.region.list, USE.NAMES = F)]

  ## Intergenic clusters:
  ## save intergenic circrnas in a BED file to be input to bedtools cluster
  ## which will tell how many cluster (putative new genes) express the circrnas
  # intergenic.circs <- circ_to_genelist[simple_gene_region == "intergenic", .(circ_id)]
  ## do not consider as intergenic the circrnas that have been detected in any gene
  ## on the opposite strand. This should compensate and fix wrong strand alignments.
  intergenic.circs <-
    circ_to_genelist[simple_gene_region == "intergenic" &
                       ! circ_id %in%
                       circ_to_genelist[simple_gene_region != "intergenic",
                                        circ_id]]

  ## this could be useful to keep track of intergenic circrnas re-assigned
  ## to genes from the opposite strand
  # ambiguously.aligned.circ.ids <-
  #     circ_to_genelist[simple_gene_region == "intergenic" &
  #                          circ_id %in%
  #                          circ_to_genelist[simple_gene_region != "intergenic",
  #                                           circ_id], circ_id]

  ## collapse intergenic circrans aligned in both the strands
  intergenic.circs <-
    intergenic.circs[,
                     lapply(.SD, function(x)list(unique(unlist(x, use.names = F)))),
                     by = circ_id]

  ## the following works since the original type of simple_gene_region in the circ_to_genelist DT is not a list
  intergenic.circs$simple_gene_region <- unlist(intergenic.circs$simple_gene_region)

  ## remove "false" intergenic and keep only full intergenic circrnas
  circ_to_genelist <-
    rbindlist(list(circ_to_genelist[simple_gene_region != "intergenic"],
                   intergenic.circs),
              use.names = T)

  if (nrow(intergenic.circs) > 0) {
    ## convert into BED format
    intergenic.circs.bed <-
      intergenic.circs[, c("chr", "coords") :=
                         tstrsplit(circ_id,
                                   ":")][, c("start",
                                             "end") :=
                                           tstrsplit(coords, "-",
                                                     type.convert = T)][, .(chr,
                                                                            start,
                                                                            end,
                                                                            circ_id)]
    intergenic.circs[, `:=`(chr = NULL, start = NULL, end = NULL, coords = NULL)]

    ## cluster circrnas irrespective of strand
    intergenic.circ.clusters <-
      merge(intergenic.circs.bed,
            get.circ.cluster(intergenic.circs.bed, max.dist = max.dist),
            by = "circ_id")
    intergenic.circ.clusters[, cluster.coords := paste0("CircClust", "_",
                                                        chr, ":", min(start),
                                                        "-", max(end)),
                             by = cluster]

    ## set cluster name as gene_name for intergenic circrnas
    circ_to_genelist <-
      merge(circ_to_genelist,
            intergenic.circ.clusters[, .(circ_id, cluster.coords)],
            by = "circ_id",
            all.x = T)[!is.na(cluster.coords),
                       gene_names := as.list(cluster.coords)][, .(circ_id, circ_strand,
                                                                  gene_ids,
                                                                  gene_names,
                                                                  gene_biotypes,
                                                                  gene_region,
                                                                  simple_gene_region,
                                                                  gene_strand)]
  }

  ### now, convert the gene lists to characters by separating genes with a bar char
  # ## faster, perhaps?
  # circ_to_genes <-
  #     circ_to_genelist[, lapply(.SD, function(x)paste0(unique(unlist(x)),
  #                                                      collapse = "|")),
  #                      by = circ_id]
  circ_to_genes <-
    circ_to_genelist[1:nrow(circ_to_genelist), ## setting the number of rows seems to run faster
                     lapply(.SD, function(x)list(unique(unlist(x, use.names = F)))),
                     by = circ_id]

  circ_to_genes[, simple_gene_region := lapply(simple_gene_region,
                                               simplify.gene.region.list)]
  circ_to_genes <- circ_to_genes[1:nrow(circ_to_genes), ## setting the number of rows seems to run faster
                                 lapply(.SD, paste.bar),
                                 by = circ_id]

  ## remove intergenic notation when a known host genes is listed
  remove.point <- function(x)sub("\\|\\.|\\.\\|", "", x)

  cols <- c("gene_ids", "gene_names", "gene_biotypes", "gene_strand")
  circ_to_genes[simple_gene_region != "intergenic",
                (cols) := lapply(.SD, remove.point), #by = circ_id,
                .SDcols = cols]

  ## convert circ_id in BED
  # circ_to_genes[, c("chr", "start",
  #                  "end"):=tstrsplit(circ_id, ":|-",
  #                                    type.convert = T)]

  ## save the table
  fwrite(x = circ_to_genes,
         file = file.path(results.path, "circ_to_genes.tsv"),
         quote = F, sep = "\t", row.names = F)

  ## GENES TO CIRCRNAS
  ## make a table with all genes in one column and corresponding circrnas in a
  ## side column, one per row, indeed duplicating gene ids if necessary
  gene_to_circ <-
    unique(gene.annotation[, .(circ_id, gene_id,
                               gene_name, gene_biotype,
                               gene_region = V12,
                               gene_strand = V16,
                               circ_strand = V7)])[, .(gene_region = list(gene_region)),
                                                   by = .(circ_id, circ_strand,
                                                          gene_id, gene_name,
                                                          gene_biotype, gene_strand)][gene_region != "intergenic"]

  ## set simple region labels
  gene_to_circ[, simple_gene_region := sapply(gene_region, simplify.gene.region.list)]

  ## convert lists into strings
  gene_to_circ <-
    gene_to_circ[, .(gene_region = paste.bar(gene_region)),
                 by = .(gene_id, gene_name, circ_id, circ_strand,
                        simple_gene_region, gene_biotype, gene_strand)]

  gene_to_circ <-
    rbindlist(list(gene_to_circ,
                   circ_to_genes[simple_gene_region == "intergenic",
                                 .(circ_id, circ_strand,
                                   gene_id = gene_ids,
                                   gene_name = gene_names,
                                   gene_biotype = gene_biotypes,
                                   gene_strand, gene_region, simple_gene_region)]),
              use.names = T)

  ## convert circ_id in BED
  # gene_to_circ[, c("chr", "start",
  #                   "end"):=tstrsplit(circ_id, ":|-",
  #                                     type.convert = T)]

  ## save table
  fwrite(x = gene_to_circ,
         file = file.path(results.path, "gene_to_circ.tsv"),
         quote = F, sep = "\t", row.names = F)


}
